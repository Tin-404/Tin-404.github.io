<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>单例模式</title>
      <link href="/posts/364ea8cc.html"/>
      <url>/posts/364ea8cc.html</url>
      
        <content type="html"><![CDATA[<h1 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><ul><li>单例模式属于<strong>创建型模式</strong>，一个单例类在任何情况下都只存在一个实例，构造方法必须是私有的、由自己创建一个静态变量存储实例，对外提供一个静态公有方法获取实例。</li><li>优点是内存中只有一个实例，减少了开销，尤其是频繁的创建和销毁实例的情况下并且可以避免对资源的多重占用。缺点是没有抽象层，难以扩展，与单一职责原则冲突。</li></ul><p><img src="https://www.runoob.com/wp-content/uploads/2014/08/62576915-36E0-4B67-B078-704699CA980A.jpg" alt="单例模式"></p><h2 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h2><p><strong>饿汉式单例模式</strong>，顾名思义，<strong>类一加载就创建对象</strong>，这种方式比较常用。<br><strong>缺点</strong></p><ul><li>容易产生垃圾对象，浪费内存空间；</li><li>单例会在加载类后一开始就被初始化，即使客户端没有调用getInstance()方法。饿汉式的创建方式在一些场景中将无法使用：例如Singleton实例的创建是依赖参数或者配置文件的，在getInstance()之前必须调用某个方法设置参数给它，那样这种单例写法就无法使用。</li></ul><p><strong>优点</strong><br><strong>线程安全，没有加锁，执行效率较高</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="comment">//1.私有化构造方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="comment">//2.定义一个静态变量指向自己类型</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    <span class="comment">//3.对外提供一个公共的方法获取实例</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><h2 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式"></a>懒汉式</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>)&#123;</span><br><span class="line">            instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>缺点</strong>：当有多个线程并行调用getInstance()的时候，就会创建多个实例。也就是说在多线程下不能正常工作。</p><p><strong>解决方案</strong>：<br>为了解决上面的问题，最简单的方法是将整个<code>getInstance()</code>方法设为同步(<code>synchronized</code>)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singeleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">        instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>此方法虽然做到了线程安全，并且解决了多实例的问题，但是它并不高效。因为在任何时候只能有一个线程调用<code>getInstance()</code>方法。<br>但是同步操作只在第一次调用时才被需要，即第一次创建单例实例对象时。</p><blockquote><p>这时候我们就需要<strong>双重检验锁</strong></p></blockquote><p><br></p><h2 id="双重检验锁-DCL-——-double-checked-locking"><a href="#双重检验锁-DCL-——-double-checked-locking" class="headerlink" title="双重检验锁(DCL —— double-checked locking)"></a>双重检验锁(DCL —— double-checked locking)</h2><p><strong>双重检验锁模式(double checked locking pattern)</strong>，是一种使用同步块加锁的方法。程序员称其为双重检查锁，因为会有两次检查<code>instance == null</code>，一次是在同步块外，一次是在同步块内。<br>为什么在同步块内还要再检验一次？因为可能会有多个线程一起进入同步块外的if，如果在同步块内不进行二次检验的话就会生成多个实例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="comment">// 声明成volatile</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这里的双重检验是指两次非空判断，锁是指<code>synchronized</code>加锁</p><ul><li><strong>第一重判断</strong>，如果实例已经存在，那么就不用再进行同步操作，而是直接返回这个实例，如果没有创建，才会进入同步块，同步块的目的与之前相同，目的是为了防止有多个线程同时调用时，生成多个实例，有了同步块，每次只能有一个线程调用访问同步块内容，当第一个抢到锁的调用获取了实例之后，这个实例就会被创建，之后的所有调用都不会进入同步块，直接在第一重判断就返回了单例；</li><li><strong>第二重空判断</strong>，当多个线程一起到达锁位置时，进行锁竞争，其中一个线程获取锁，如果是第一次进入则为null，会进行单例对象的创建，完成后释放锁，其他线程获取锁后就会被空判断拦截，直接返回已创建的单例对象。</li></ul><p><code>instance = new Singleton()</code>并非是一个原子操作，事实上在JVM中这句话大概做了一下三件事：</p><ol><li>给<code>instance</code>分配内存</li><li>调用<code>Singleton</code>的构造函数来初始化成员变量</li><li>将<code>instance</code>对象指向分配的内存空间(执行完这步<code>instance</code>就为非null了)</li></ol><p>但在JVM 的即时编译器中存在指令重排序的优化。也就是说上面的第二步和第三步的顺序是不能保证的，最终的执行顺序可能是1-2-3也可能是1-3-2.如果是后者，则在3执行完毕，2未执行之前，被线程二抢占了，这时<code>instance</code>已经是非null了(但是没有初始化)，所以线程二会直接返回<code>instance</code>，然后使用，这时就会出错</p><blockquote><p>将<code>instance</code>变量声明成<code>volatile</code>就可以避免了</p></blockquote><p><br></p><h2 id="Why-volatile"><a href="#Why-volatile" class="headerlink" title="Why volatile ?"></a>Why volatile ?</h2><p>有些人认为使用<code>volatile</code>的原因是可见性，也就是可以保证线程在本地不会存有<code>instance</code>的副本，每次都是去主内存中读取。但其实是不对的。使用<code>volatile</code>的主要原因是其另外一个特性：<strong>禁止指令重排序优化</strong>。<br>也就是说，在<code>volatile</code>变量的赋值操作后面会有一个<strong>内存屏障</strong>(生成的汇编代码上)，读操作不会被重排序到内存屏障之前。比如上面的例子，取操作必须在执行完1-2-3之后或者1-3-2之后，不存在执行到1-3然后取到值的情况。<br>从<strong>先行发生原则</strong>的角度理解的话，就是对于一个volatile变量的写操作都先行发生于后面对这个变量的读操作。<br>但是Java5之前的版本使用volatile的双检锁还是有问题的。其原因是Java5以前的JMM(Java内存模型)是存在缺陷的，即使将变量声明成volatile也不能完全避免重排序，主要是volatile变量前后的代码仍然存在重排序问题。这个volatile屏蔽重排序的问题在Java5中才得以修复。</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>动态规划</title>
      <link href="/posts/a80d0031.html"/>
      <url>/posts/a80d0031.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>排序算法</title>
      <link href="/posts/735e5788.html"/>
      <url>/posts/735e5788.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>贪心算法</title>
      <link href="/posts/a4ce31d2.html"/>
      <url>/posts/a4ce31d2.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>回溯算法</title>
      <link href="/posts/376d0826.html"/>
      <url>/posts/376d0826.html</url>
      
        <content type="html"><![CDATA[<h1 id="回溯算法"><a href="#回溯算法" class="headerlink" title="回溯算法"></a>回溯算法</h1>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>二叉树</title>
      <link href="/posts/e85d694a.html"/>
      <url>/posts/e85d694a.html</url>
      
        <content type="html"><![CDATA[<h1 id="二叉树的基本理论"><a href="#二叉树的基本理论" class="headerlink" title="二叉树的基本理论"></a>二叉树的基本理论</h1><h2 id="从二叉树的总类"><a href="#从二叉树的总类" class="headerlink" title="从二叉树的总类"></a>从二叉树的总类</h2><p>特殊的二叉树主要有两种：满二叉树和完全二叉树</p><h3 id="满二叉树"><a href="#满二叉树" class="headerlink" title="满二叉树"></a>满二叉树</h3><p>满二叉树：二叉树只有结点为0的结点和度为2的结点，并且度为0的结点在同一层上<br>如下图<br><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20200806185805576.png" alt="满二叉树"><br>这棵树为满二叉树，深度为k时，有2^k-1个结点</p><h3 id="完全二叉树"><a href="#完全二叉树" class="headerlink" title="完全二叉树"></a>完全二叉树</h3><p>完全二叉树：出来最底层结点没有被填满外，其余层结点数都达到最大，且最下面一层结点是从最左边连续<br>最底层有1~2^(k-1)个结点<br><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20200920221638903.png" alt="完全二叉树"><br>优先级队列其实就是一个堆，堆就是一颗完全二叉树，同时保证父子结点的顺序关系</p><h3 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h3><p>二叉搜索树是一棵中序遍历有序的树</p><ul><li>左子树上结点小于根结点值</li><li>右子树上结点大于根结点值<br><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20200806190304693.png" alt="二叉搜索树"><br>如上两个都是二叉搜索树</li></ul><h3 id="平衡二叉搜索树"><a href="#平衡二叉搜索树" class="headerlink" title="平衡二叉搜索树"></a>平衡二叉搜索树</h3><p>平衡二叉搜索树: 也称AVL(Adelson-Velsky and Landis)树，它左右两个树的高度差绝对值不超过1，且左右两棵<br>子树都是平衡二叉树。n个结点的平衡二叉搜索树高度可保持在 O(logN)，搜索时间复杂度O(logN )<br><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20200806190511967.png" alt="平衡二叉搜索树"><br>最后一棵不是因为高度差绝对值超过了1.</p><p>java中map和set底层实现是红黑树，这个以后找个篇章特意写吧！</p><h2 id="二叉树的存储方式"><a href="#二叉树的存储方式" class="headerlink" title="二叉树的存储方式"></a>二叉树的存储方式</h2><blockquote><p>二叉树可以链式存储，也可以顺序存储。链式存储使用指针，顺序存储使用数组</p></blockquote><p><code>链式存储数据结构</code></p><pre><code>public class TreeNode &#123;    int val;    TreeNode left;    TreeNode right;    public TreeNode()&#123;    &#125;    public TreeNode(int val)&#123;        this.val = val;    &#125;    public TreeNode(int val,TreeNode left,TreeNode right)&#123;        this.val = val;        this.left = left;        this.right = right;    &#125;&#125;</code></pre><blockquote><p>当使用数组存储二叉树时，若父节点下标是i，则其左孩子下标为2i+1，右孩子为2i+2。</p></blockquote><p><code>在Java中输入数组使其构成树</code></p><pre><code>public class Solution &#123;    static class TreeNode&#123;        int val;        TreeNode left;        TreeNode right;        public TreeNode()&#123;&#125;        public TreeNode(int val)&#123;            this.val = val;            this.left = null;            this.right = null;        &#125;    &#125;    public static void main(String[] args) &#123;        int[] arr = new int[7];        Scanner in = new Scanner(System.in);        for (int i = 0;i &lt; arr.length;i++)&#123;            arr[i] = in.nextInt();        &#125;        Solution solution = new Solution();        TreeNode root = solution.constructBinaryTree(arr);        System.out.println(root.right.right.val);    &#125;    public TreeNode constructBinaryTree(final int[] arr)&#123;        // 初始树        List&lt;TreeNode&gt; treeNodeList = arr.length &gt; 0 ? new ArrayList&lt;&gt;(arr.length) : null;        TreeNode root = null;        // 给树各个结点赋值        for (int i = 0;i &lt; arr.length;i++)&#123;            TreeNode node = null;            if (arr[i] != -1)&#123;                node = new TreeNode(arr[i]);            &#125;            treeNodeList.add(node);            if (i == 0)&#123;                root = node;            &#125;        &#125;        // 指定树结点的左右孩子        for (int i = 0;i * 2 + 1&lt;arr.length;i++)&#123;            TreeNode node = treeNodeList.get(i);            if (node != null)&#123;                // 左孩子2i+1                node.left = treeNodeList.get(2 * i + 1);                // 右孩子2i+2                if (i * 2 + 2 &lt; arr.length)&#123;                    node.right = treeNodeList.get(2 * i + 2);                &#125;            &#125;        &#125;        return root;    &#125;&#125;</code></pre><h2 id="二叉树的遍历方式"><a href="#二叉树的遍历方式" class="headerlink" title="二叉树的遍历方式"></a>二叉树的遍历方式</h2><blockquote><p>二叉树主要有两种遍历方式：</p><ol><li>深度优先遍历：先往深走，遇到叶子结点再往回走<ul><li>前序遍历(递归法，迭代法)</li><li>中序遍历(递归法，迭代法)</li><li>后序遍历(递归法，迭代法)</li></ul></li><li>广度优先遍历：一层一层的去遍历<ul><li>层次遍历(递归法，迭代法)</li></ul></li></ol></blockquote><h3 id="二叉树的深度优先遍历"><a href="#二叉树的深度优先遍历" class="headerlink" title="二叉树的深度优先遍历"></a>二叉树的深度优先遍历</h3><blockquote><p>主要记录深度优先的递归法，迭代法可以借助栈来实现<br>在进行递归时也会使用到栈，但是这个栈是由内存自己为我们分配的</p><p>二叉树的前序遍历是从上往下的遍历方式</p></blockquote><p><code>前序遍历的递归法</code></p><pre><code>public List&lt;Integer&gt; preorderTraversal(TreeNode root)&#123;    List&lt;Integer&gt; res = new ArrayList&lt;&gt;();    preorder(root,res);    return res;&#125;public void preorder(TreeNode root,List&lt;Integer&gt; res)&#123;    if (root == null)&#123;        return;    &#125;    res.add(root.val);    preorder(root.left,res);    preorder(root.right,res);&#125;</code></pre><blockquote><p>二叉搜索树的中序遍历是有序的</p></blockquote><p><code>中序遍历的递归法</code></p><pre><code>public List&lt;Integer&gt; inorderTraversal(TreeNode root) &#123;    List&lt;Integer&gt; res = new ArrayList&lt;&gt;();    inorder(root, res);    return res;&#125;public void inorder(TreeNode root, List&lt;Integer&gt; res) &#123;    if (root == null) &#123;        return;    &#125;    inorder(root.left, res);    res.add(root.val);    inorder(root.right, res);&#125;</code></pre><blockquote><p>二叉树的后序遍历是从下往上的遍历方式</p></blockquote><p><code>后序遍历的递归法</code></p><pre><code>public List&lt;Integer&gt; postorderTraversal(TreeNode root) &#123;    List&lt;Integer&gt; res = new ArrayList&lt;&gt;();    postorder(root, res);    return res;&#125;public void postorder(TreeNode root, List&lt;Integer&gt; res) &#123;    if (root == null) &#123;        return;    &#125;    preorder(root.left, res);    preorder(root.right, res);    res.add(root.val);&#125;</code></pre><h3 id="二叉树的广度优先遍历"><a href="#二叉树的广度优先遍历" class="headerlink" title="二叉树的广度优先遍历"></a>二叉树的广度优先遍历</h3><blockquote><p>广度优先遍历也可使用递归法与迭代法<br>递归法是每一层作为一个递归<br>迭代法则是借助队列</p></blockquote><p><code>二叉树的广度优先遍历</code></p><pre><code>List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;    levelOne(root, 0);    levelTwo(root);    return res;&#125;// 递归法public void levelOne(TreeNode root, int depth) &#123;    if (root == null) &#123;        return;    &#125;    depth++;    if (res.size() &lt; depth) &#123;        List&lt;Integer&gt; item = new ArrayList&lt;&gt;();        res.add(item);    &#125;    res.get(depth - 1).add(root.val);    levelOne(root.left, depth);    levelOne(root.right, depth);&#125;// 迭代法，借助队列public void levelTwo(TreeNode root) &#123;    if (root == null) &#123;        return;    &#125;    Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;();    queue.offer(root);    while (!queue.isEmpty()) &#123;        List&lt;Integer&gt; item = new ArrayList&lt;&gt;();        int len = queue.size();        while (len &gt; 0) &#123;            TreeNode temp = queue.poll();            item.add(temp.val);            if (temp.left != null) &#123;                queue.offer(temp.left);            &#125;            if (temp.right != null) &#123;                queue.offer(temp.right);            &#125;            len--;        &#125;        res.add(item);    &#125;&#125;</code></pre><blockquote><p>对于二叉树的相关特征以及算法主要有以下</p></blockquote><h2 id="二叉树的属性"><a href="#二叉树的属性" class="headerlink" title="二叉树的属性"></a>二叉树的属性</h2><h3 id="1-二叉树是否对称-101-对称二叉树"><a href="#1-二叉树是否对称-101-对称二叉树" class="headerlink" title="(1)二叉树是否对称:101.对称二叉树"></a><a href="https://leetcode.cn/problems/symmetric-tree/">(1)二叉树是否对称:101.对称二叉树</a></h3><p>给定一个二叉树，判断其是不是对称的，如下图<br><img src="https://assets.leetcode.com/uploads/2021/02/19/symtree1.jpg" alt="二叉树"></p><blockquote><p>判断一棵树是不是轴对称，既是判断根节点的左子树和右子树是不是翻转的，也就是左的左是否等于右的右，<br>左的右是不是等于右的左，使用递归对每个结点进行判断；<br>也可以借助队列，将左右结点按照顺序放入队列中进行比较。</p></blockquote><p><code>递归法</code></p><pre><code>public boolean isSymmetric(TreeNode root) &#123;    return compare(root.left,root.right);&#125;public boolean compare(TreeNode left,TreeNode right)&#123;    if (left == null &amp;&amp; right != null)&#123;        return false;    &#125;    if (left != null &amp;&amp; right == null)&#123;        return false;    &#125;    if (left == null &amp;&amp; right == null)&#123;        return true;    &#125;    if (left.val != right.val)&#123;        return false;    &#125;    // 比较外侧    boolean outside = compare(left.left,right.right);    // 比较内侧    boolean inside = compare(left.right,right.left);    return outside &amp;&amp; inside;&#125;</code></pre><p><code>迭代法</code></p><pre><code>public boolean isSymmetric(TreeNode root) &#123;    Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;();    queue.offer(root.left);    queue.offer(root.right);    while (!queue.isEmpty())&#123;        TreeNode left = queue.poll();        TreeNode right = queue.poll();        if (left == null &amp;&amp; right == null)&#123;            continue;        &#125;        if (left == null || right == null || left.val != right.val)&#123;            return false;        &#125;        // 按照左左，右右，左右，右左顺序加入队列        queue.offer(left.left);        queue.offer(right.right);        queue.offer(left.right);        queue.offer(right.left);    &#125;    return true;&#125;</code></pre><h3 id="2-求二叉树的最大深度和最小深度"><a href="#2-求二叉树的最大深度和最小深度" class="headerlink" title="(2)求二叉树的最大深度和最小深度"></a>(2)求二叉树的最大深度和最小深度</h3><p><a href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/">最大深度</a><br><a href="https://leetcode.cn/problems/minimum-depth-of-binary-tree/">最小深度</a></p><blockquote><p>求最大深度，通过递归法，递归返回的值即是树的深度，也可以同迭代法进行层序遍历，每遍历一层将depth++；<br>求最小深度，通过递归法，找到第一个左右结点都为空的结点即为最小深度结点；通过迭代法进行层序遍历，第一个左右结点都为空<br>的结点即为最小深度结点。</p></blockquote><p><code>最大深度递归法</code></p><pre><code>public int maxDepth(TreeNode root) &#123;    if (root == null) &#123;        return 0;    &#125; else &#123;        int left = maxDepth(root.left);        int right = maxDepth(root.right);        return Math.max(left, right) + 1;    &#125; &#125;</code></pre><p><code>最大深度迭代法</code></p><pre><code>public int maxDepth(TreeNode root) &#123;    if (root == null)&#123;        return 0;    &#125;    Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;();    queue.offer(root);    int deep = 0;    while (!queue.isEmpty())&#123;        int len = queue.size();        while (len &gt; 0)&#123;            TreeNode temp = queue.poll();            if (temp.left != null)&#123;                queue.offer(temp.left);            &#125;            if (temp.right != null) &#123;                queue.offer(temp.right);            &#125;            len--;        &#125;        // 借助队列，没迭代一层之后深度++；        deep++;    &#125;    return deep;&#125;</code></pre><p><code>最小深度递归法</code></p><pre><code>public int minDepth(TreeNode root) &#123;    if (root == null) &#123;        return 0;    &#125;    int leftDepth = minDepth(root.left);    int rightDepth = minDepth(root.right);    if (root.left == null) &#123;        return rightDepth + 1;    &#125;    if (root.right == null) &#123;        return leftDepth + 1;    &#125;    // 左右结点都不为null    return Math.min(leftDepth, rightDepth) + 1;&#125;</code></pre><p><code>最小深度迭代法</code></p><pre><code>public int minDepth(TreeNode root) &#123;    if(root == null)&#123;        return 0;    &#125;    Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;();    queue.offer(root);    int depth = 0;    while (!queue.isEmpty())&#123;        int len = queue.size();        depth++;        TreeNode temp = null;        while (len &gt; 0)&#123;            temp = queue.poll();            // 当遇到第一个左右结点都为空的直接返回。            if (temp.left == null &amp;&amp; temp.right==null)&#123;                return depth;            &#125;            if (temp.left != null)&#123;                queue.offer(temp.left);            &#125;            if (temp.right != null)&#123;                queue.offer(temp.right);            &#125;            len--;        &#125;    &#125;    return depth;&#125;</code></pre><h3 id="3-求二叉树结点个数"><a href="#3-求二叉树结点个数" class="headerlink" title="(3)求二叉树结点个数"></a><a href="https://leetcode.cn/problems/count-complete-tree-nodes/">(3)求二叉树结点个数</a></h3><blockquote><p>直接通过递归法，递归次数即为结点个数<br>也可以借助队列，队列中每加入一个结点，则结点总个数++</p></blockquote><p><code>递归法</code></p><pre><code>public int countNodes(TreeNode root) &#123;    if (root == null)&#123;        return 0;    &#125;    return countNodes(root.left) + countNodes(root.right) + 1;&#125;</code></pre><p><code>迭代法</code></p><pre><code>public int countNodes(TreeNode root) &#123;    if (root == null)&#123;        return 0;    &#125;    Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;();    queue.offer(root);    int result = 0;    while (!queue.isEmpty())&#123;        int len = queue.size();        while (len &gt; 0)&#123;            TreeNode temp = queue.poll();            // 统计结点个数            result++;            if (temp.left != null)&#123;                queue.offer(temp.left);            &#125;            if (temp.right != null)&#123;                queue.offer(temp.right);            &#125;            len--;        &#125;    &#125;    return result;&#125;</code></pre><h3 id="4-二叉树是否平衡"><a href="#4-二叉树是否平衡" class="headerlink" title="(4)二叉树是否平衡"></a><a href="https://leetcode.cn/problems/balanced-binary-tree/">(4)二叉树是否平衡</a></h3><blockquote><p>判断二叉树是否平衡即每一个结点都需要进行判断，对每一个结点进行左右子树高度比较，所以我们可以通过<br>后序遍历来做,使用-1做为不平衡的标志</p></blockquote><p><code>递归后序遍历</code></p><pre><code>public boolean isBalanced(TreeNode root) &#123;    return getHeight(root) != -1;&#125;private int getHeight(TreeNode root) &#123;    if (root == null) &#123;        return 0;    &#125;    int leftHeight = getHeight(root.left);    if (leftHeight == -1) &#123;        return -1;    &#125;    int rightHeight = getHeight(root.right);    if (rightHeight == -1) &#123;        return -1;    &#125;    // 左右子树高度差大于1，return -1表示已经不是平衡树了    if (Math.abs(leftHeight - rightHeight) &gt; 1) &#123;        return -1;    &#125;    return Math.max(leftHeight, rightHeight) + 1;&#125;</code></pre><h3 id="5-求所有路径"><a href="#5-求所有路径" class="headerlink" title="(5)求所有路径"></a><a href="https://leetcode.cn/problems/binary-tree-paths/">(5)求所有路径</a></h3><blockquote><p>求根节点到所有叶子结点的路径，可以很简单的使用深度优先遍历直到叶子结点<br>使用前序遍历使父节点指向子节点，直到子节点的左右孩子都为空<br>也可以使用迭代法，借助栈，非空时一直往站内添加元素</p></blockquote><p><code>递归法</code></p><pre><code>public List&lt;String&gt; binaryTreePaths(TreeNode root) &#123;    List&lt;String&gt; res = new ArrayList&lt;&gt;();    if (root == null)&#123;        return res;    &#125;    dfs(root,&quot;&quot;,res);    return res;&#125;public void dfs(TreeNode node,String path,List&lt;String&gt; res)&#123;    if (node != null)&#123;        StringBuffer sb = new StringBuffer(path);        sb.append(Integer.toString(node.val));        if (node.left == null &amp;&amp; node.right==null)&#123;            res.add(sb.toString());        &#125; else &#123;          sb.append(&quot;-&gt;&quot;);          dfs(node.left,sb.toString(),res);          dfs(node.right,sb.toString(),res);        &#125;    &#125;&#125;</code></pre><p><code>迭代法</code></p><pre><code>public List&lt;String&gt; binaryTreePaths(TreeNode root) &#123;    if (root == null)&#123;        return null;    &#125;    List&lt;String&gt; res = new ArrayList&lt;&gt;();    Stack&lt;Object&gt; stack = new Stack&lt;&gt;();    // 节点和路径同时入栈    stack.push(root);    stack.push(root.val + &quot;&quot;);    while (!stack.isEmpty())&#123;        // 节点和路径同时出栈        String path = (String) stack.pop();        TreeNode node = (TreeNode) stack.pop();        // 若找到叶子节点        if (node.left == null &amp;&amp; node.right==null)&#123;            res.add(path);        &#125;        //右子节点不为空        if (node.right!=null)&#123;            stack.push(node.right);            stack.push(path + &quot;-&gt;&quot; + node.right.val);        &#125;        //左子节点不为空        if (node.left != null)&#123;            stack.push(node.left);            stack.push(path + &quot;-&gt;&quot; + node.left.val);        &#125;    &#125;    return res;&#125;</code></pre><h3 id="6-求左叶子的和"><a href="#6-求左叶子的和" class="headerlink" title="(6)求左叶子的和"></a><a href="https://leetcode.cn/problems/sum-of-left-leaves/">(6)求左叶子的和</a></h3><blockquote><p>某一结点是左叶子的条件是此结点是一结点的左结点且左结点没有左右孩子<br>根据这一条件就可以很轻松的通过迭代法或递归法来求左叶子的和</p></blockquote><p><code>递归法</code></p><pre><code>public int sumOfLeftLeaves(TreeNode root) &#123;    if (root == null)&#123;        return 0;    &#125;    int leftValue = sumOfLeftLeaves(root.left);  //左    int rightValue = sumOfLeftLeaves(root.right); //右    int midValue = 0;    if (root.left != null &amp;&amp; root.left.left == null &amp;&amp; root.left.right == null)&#123;        midValue = root.left.val;    &#125;    int sum = leftValue + rightValue + midValue;    return sum;&#125;</code></pre><p><code>迭代法</code></p><pre><code>public int sumOfLeftLeaves(TreeNode root) &#123;    int res = 0;    if (root == null)&#123;        return res;    &#125;    Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;();    queue.offer(root);    while (!queue.isEmpty())&#123;        int len = queue.size();        while (len &gt; 0)&#123;            TreeNode temp = queue.poll();            // 判断叶子结点            if (temp.left != null &amp;&amp; temp.left.left == null &amp;&amp; temp.left.right ==null)&#123;                res = res + temp.left.val;            &#125;            if (temp.left != null)&#123;                queue.offer(temp.left);            &#125;            if (temp.right != null)&#123;                queue.offer(temp.right);            &#125;            len--;        &#125;    &#125;    return res;&#125;</code></pre><h2 id="二叉树的修改与改造"><a href="#二叉树的修改与改造" class="headerlink" title="二叉树的修改与改造"></a>二叉树的修改与改造</h2><h3 id="1-翻转二叉树"><a href="#1-翻转二叉树" class="headerlink" title="(1)翻转二叉树"></a><a href="https://leetcode.cn/problems/invert-binary-tree/">(1)翻转二叉树</a></h3><blockquote><p>使用递归法前序遍历交换左右孩子，或使用迭代法借助队列模拟前序遍历</p></blockquote><p><code>递归法</code></p><pre><code>/** * 前后序遍历都可以 * 中序不行，因为先左孩子交换孩子，再根交换孩子（做完后，右孩子已经变成了原来的左孩子）， * 再右孩子交换孩子（此时其实是对原来的左孩子做交换） */public TreeNode invertTree(TreeNode root) &#123;    reverse(root);    return root;&#125;public void reverse(TreeNode node)&#123;    if (node == null)&#123;        return;    &#125;    TreeNode temp = node.left;    node.left = node.right;    node.right = temp;    reverse(node.left);    reverse(node.right);&#125;</code></pre><p><code>迭代法</code></p><pre><code>public TreeNode invertTree(TreeNode root) &#123;    if (root == null)&#123;        return null;    &#125;    ArrayDeque&lt;TreeNode&gt; deque = new ArrayDeque&lt;&gt;();    deque.offer(root);    while (!deque.isEmpty())&#123;        int size = deque.size();        while (size-- &gt; 0)&#123;            TreeNode node = deque.poll();            swap(node);            if (node.left != null)&#123;                deque.offer(node.left);            &#125;            if (node.right != null)&#123;                deque.offer(node.right);            &#125;        &#125;    &#125;    return root;&#125;public void swap(TreeNode root)&#123;    TreeNode temp = root.left;    root.left = root.right;    root.right = temp;&#125;</code></pre><h3 id="2-构造二叉树"><a href="#2-构造二叉树" class="headerlink" title="(2)构造二叉树"></a><a href="https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/">(2)构造二叉树</a></h3><blockquote><p>给定两个整数数组 inorder 和 postorder ，其中 inorder 是二叉树的中序遍历，<br>postorder 是同一棵树的后序遍历，构造并返回这颗二叉树。<br><img src="https://i.328888.xyz/2023/04/17/ieNd8L.jpeg" alt="中序后序"><br>如上图所画在后序遍历中最后一个结点即为根结点，对应中序遍历，3的左边即为左子树，右边即为右子树<br>后序遍历根结点前一个结点即为右子树第一个结点，右子树所有结点前一个结点即为左子树第一个结点，对应<br>到中序遍历根据父节点依次寻找子节点</p></blockquote><pre><code>Map&lt;Integer, Integer&gt; map;  // 方便根据数值查找位置public TreeNode buildTree(int[] inorder, int[] postorder) &#123;    map = new HashMap&lt;&gt;();    for (int i = 0; i &lt; inorder.length; i++) &#123; // 用map保存中序序列的数值对应位置        map.put(inorder[i], i);    &#125;    return findNode(inorder,  0, inorder.length, postorder,0, postorder.length);  // 前闭后开&#125;public TreeNode findNode(int[] inorder, int inBegin, int inEnd, int[] postorder, int postBegin, int postEnd) &#123;    // 参数里的范围都是前闭后开    if (inBegin &gt;= inEnd || postBegin &gt;= postEnd) &#123;  // 不满足左闭右开，说明没有元素，返回空树        return null;    &#125;    int rootIndex = map.get(postorder[postEnd - 1]);  // 找到后序遍历的最后一个元素在中序遍历中的位置    TreeNode root = new TreeNode(inorder[rootIndex]);  // 构造结点    int lenOfLeft = rootIndex - inBegin;  // 保存中序左子树个数，用来确定后序数列的个数    root.left = findNode(inorder, inBegin, rootIndex,                        postorder, postBegin, postBegin + lenOfLeft);    root.right = findNode(inorder, rootIndex + 1, inEnd,                        postorder, postBegin + lenOfLeft, postEnd - 1);    return root;&#125;</code></pre><h3 id="3-构造最大二叉树"><a href="#3-构造最大二叉树" class="headerlink" title="(3)构造最大二叉树"></a><a href="https://leetcode.cn/problems/maximum-binary-tree/">(3)构造最大二叉树</a></h3><blockquote><p>给定一个不重复的整数数组 nums 。 最大二叉树 可以用下面的算法从 nums 递归地构建:<br>创建一个根节点，其值为 nums 中的最大值。<br>递归地在最大值 左边 的 子数组前缀上 构建左子树。<br>递归地在最大值 右边 的 子数组后缀上 构建右子树。</p><p>这个题通过递归可以很快的做出来，即找到最大值做根，左边做左子树，右边做右子树</p></blockquote><p><code>迭代法</code></p><pre><code>public TreeNode constructMaximumBinaryTree(int[] nums) &#123;    return constructMaximumBinaryTree1(nums, 0, nums.length);&#125;public TreeNode constructMaximumBinaryTree1(int[] nums, int leftIndex, int rightIndex) &#123;    if (rightIndex - leftIndex &lt; 1) &#123;// 没有元素了        return null;    &#125;    if (rightIndex - leftIndex == 1) &#123;// 只有一个元素        return new TreeNode(nums[leftIndex]);    &#125;    int maxIndex = leftIndex;// 最大值所在位置    int maxVal = nums[maxIndex];// 最大值    for (int i = leftIndex + 1; i &lt; rightIndex; i++) &#123;        if (nums[i] &gt; maxVal)&#123;            maxVal = nums[i];            maxIndex = i;        &#125;    &#125;    TreeNode root = new TreeNode(maxVal);    // 根据maxIndex划分左右子树    root.left = constructMaximumBinaryTree1(nums, leftIndex, maxIndex);    root.right = constructMaximumBinaryTree1(nums, maxIndex + 1, rightIndex);    return root;&#125;</code></pre><blockquote><p>而另外一种方式则是通过单调栈<br>我们我们通过递归操作的时候，会发现虽然每次都对数组进行了拆分操作，但是，对数组中的元素也会进行多次的重复遍历，那么有没有一种方式，可以仅通过对数组nums的一次遍历，就可以得出最终结果的呢？ 其实有的，我们可以通过单调栈的方式进行操作。<br>采用单调栈的基本思路是这样的：</p><ol><li>如果栈顶元素大于待插入的元素，那么直接入栈。</li><li>如果栈顶元素小于待插入的元素，那么栈顶元素出栈。</li></ol><p>当然，在对比两个节点大小和出入栈的同时，依然还是会根据题意，进行二叉树的构造。即：</p><ul><li>如果栈顶元素大于待插入的元素，则：栈顶元素.right = 待插入元素。</li><li>如果栈顶元素小于待插入的元素，则：待插入元素.left = 栈顶元素。<br>我们依然以nums = [3,2,1,6,0,5]为例，看一下通过单调栈是怎么创建二叉树的。<br><img src="https://pic.leetcode-cn.com/1660983422-ivHnrW-1.png" alt="1"><br><img src="https://pic.leetcode-cn.com/1660983435-LSVAnP-1.png" alt="2"><br><img src="https://pic.leetcode-cn.com/1660983451-ofGVFw-1.png" alt="3"><br><img src="https://pic.leetcode-cn.com/1660983463-ErjdMy-1.png" alt="4"></li></ul></blockquote><p><code>单调栈</code></p><pre><code>public TreeNode constructMaximumBinaryTree(int[] nums) &#123;    Deque&lt;TreeNode&gt; deque = new ArrayDeque();    for (int i = 0; i &lt; nums.length; i++) &#123;        TreeNode node = new TreeNode(nums[i]);        while(!deque.isEmpty()) &#123;            TreeNode topNode = deque.peekLast();            if (topNode.val &gt; node.val) &#123;                deque.addLast(node);                topNode.right = node;                break;            &#125; else &#123;                deque.removeLast(); // 出栈操作                node.left = topNode;            &#125;        &#125;        if (deque.isEmpty()) deque.addLast(node);    &#125;    return deque.peek();&#125;</code></pre><h2 id="二叉搜索树的属性"><a href="#二叉搜索树的属性" class="headerlink" title="二叉搜索树的属性"></a>二叉搜索树的属性</h2><h3 id="1-是不是二叉搜索树"><a href="#1-是不是二叉搜索树" class="headerlink" title="(1)是不是二叉搜索树"></a><a href="https://leetcode.cn/problems/validate-binary-search-tree/">(1)是不是二叉搜索树</a></h3><blockquote><p>给定一个二叉树的根节点 root ，判断其是否是一个有效的二叉搜索树。<br>有效二叉搜索树定义如下：</p><ul><li>节点的左子树只包含 小于 当前节点的数。</li><li>节点的右子树只包含 大于 当前节点的数。</li><li>所有左子树和右子树自身必须也是二叉搜索树。</li></ul><p>二叉搜索树的中序遍历得到的是一个有序的，所以只需要中序遍历之后判断后一个结点是不是比前一个结点值大</p></blockquote><pre><code>long pre = Long.MIN_VALUE;public boolean isValidBST(TreeNode root) &#123;    return inorder(root);&#125;public boolean inorder(TreeNode node)&#123;    if (node == null)&#123;        return true;    &#125;    boolean l = inorder(node.left);    if (node.val &lt;= pre)&#123;        return false;    &#125;    pre = node.val;    boolean r = inorder(node.right);    return l&amp;&amp;r;&#125;</code></pre><h3 id="2-求二叉搜索树的众数"><a href="#2-求二叉搜索树的众数" class="headerlink" title="(2)求二叉搜索树的众数"></a><a href="https://leetcode.cn/problems/find-mode-in-binary-search-tree/">(2)求二叉搜索树的众数</a></h3><blockquote><p>给你一个含重复值的二叉搜索树（BST）的根节点 root ，找出并返回 BST 中的所有 众数（即，出现频率最高的元素）。<br>如果树中有不止一个众数，可以按 任意顺序 返回。<br>假定 BST 满足如下定义：</p><ul><li>结点左子树中所含节点的值 小于等于 当前节点的值</li><li>结点右子树中所含节点的值 大于等于 当前节点的值</li><li>左子树和右子树都是二叉搜索树</li></ul><p>二叉搜索树的中序遍历是有序的，用hash表做中序遍历用node.val做key，用相同的个数做value，输出个数最大的即可</p></blockquote><pre><code>Map&lt;Integer,Integer&gt; map = new HashMap&lt;&gt;();public int[] findMode(TreeNode root) &#123;    if (root == null)&#123;        return new int[0];    &#125;    inorder(root);    List&lt;Integer&gt; list = new ArrayList&lt;&gt;();    List&lt;Map.Entry&lt;Integer, Integer&gt;&gt; mapList = map.entrySet().stream()            .sorted((c1, c2) -&gt; c2.getValue().compareTo(c1.getValue()))            .collect(Collectors.toList());    list.add(mapList.get(0).getKey());    // 把频率最高的加入 list    for (int i = 1; i &lt; mapList.size(); i++) &#123;        if (mapList.get(i).getValue() == mapList.get(i - 1).getValue()) &#123;            list.add(mapList.get(i).getKey());        &#125; else &#123;            break;        &#125;    &#125;    return list.stream().mapToInt(Integer::intValue).toArray();&#125;public void inorder(TreeNode node)&#123;    if (node == null)&#123;        return;    &#125;    inorder(node.left);    map.put(node.val, map.getOrDefault(node.val,0)+1);    inorder(node.right);&#125;</code></pre><blockquote><p>也可以利用二叉搜索树的特性，将数使用count来进行计数，使用maxCount记录出现的最大次数，<br>相等则加入结果数组，当count大于maxCount时表明出现了新的最大次数的数，清除结果数组中所有<br>的数更新maxCount</p></blockquote><pre><code>ArrayList&lt;Integer&gt; resList;int maxCount;int count;TreeNode pre;public int[] findMode(TreeNode root) &#123;    resList = new ArrayList&lt;&gt;();    maxCount = 0;    count = 0;    pre = null;    findMode1(root);    int[] res = new int[resList.size()];    for (int i = 0; i &lt; resList.size(); i++) &#123;        res[i] = resList.get(i);    &#125;    return res;&#125;public void findMode1(TreeNode root) &#123;    if (root == null) &#123;        return;    &#125;    findMode1(root.left);    int rootValue = root.val;    // 计数    if (pre == null || rootValue != pre.val) &#123;        count = 1;    &#125; else &#123;        count++;    &#125;    // 更新结果以及maxCount    if (count &gt; maxCount) &#123;        resList.clear();        resList.add(rootValue);        maxCount = count;    &#125; else if (count == maxCount) &#123;        resList.add(rootValue);    &#125;    pre = root;    findMode1(root.right);&#125;</code></pre><h2 id="二叉树公共祖先问题"><a href="#二叉树公共祖先问题" class="headerlink" title="二叉树公共祖先问题"></a>二叉树公共祖先问题</h2><p><a href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/">二叉树的最近公共祖先</a></p><blockquote><p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。<br>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，<br>满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</p><p>使用后序遍历从而能先知道两个结点位置从而找到最近公共祖先</p></blockquote><pre><code>public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) &#123;   if (root == null || root == p || root == q)&#123;        return root;    &#125;    TreeNode left = lowestCommonAncestor(root.left,p,q);    TreeNode right = lowestCommonAncestor(root.right,p,q);    if (right == null)&#123;        return left;    &#125;    if (left == null)&#123;        return right;    &#125;    return root;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>开始</title>
      <link href="/posts/0.html"/>
      <url>/posts/0.html</url>
      
        <content type="html"><![CDATA[<h1 id="记录"><a href="#记录" class="headerlink" title="记录"></a>记录</h1><div class="tip info"><ul><li>无回顾，不成长 </li></ul></div><h1 id="…"><a href="#…" class="headerlink" title="…"></a>…</h1><h1 id="123"><a href="#123" class="headerlink" title="123"></a>123</h1>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/posts/16107.html"/>
      <url>/posts/16107.html</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title></title>
      <link href="/manifest.json"/>
      <url>/manifest.json</url>
      
        <content type="html"><![CDATA[{"name":"LIFE","short_name":"WENJD","theme_color":"#3b70fc","background_color":"#3b70fc","display":"standalone","scope":"/","start_url":"/","icons":[{"src":"/img/siteicon/16.png","sizes":"16x16","type":"image/png"},{"src":"/img/siteicon/32.png","sizes":"32x32","type":"image/png"},{"src":"/img/siteicon/48.png","sizes":"48x48","type":"image/png"},{"src":"/img/siteicon/64.png","sizes":"64x64","type":"image/png"},{"src":"/img/siteicon/128.png","sizes":"128x128","type":"image/png"},{"src":"/img/siteicon/144.png","sizes":"144x144","type":"image/png"},{"src":"/img/siteicon/512.png","sizes":"512x512","type":"image/png"}],"splash_pages":null}]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/css/custom.css"/>
      <url>/css/custom.css</url>
      
        <content type="html"><![CDATA[/* @font-face {  font-family: Candyhome;  src: url(https://npm.elemecdn.com/anzhiyu-blog@1.1.6/fonts/Candyhome.ttf);  font-display: swap;  font-weight: lighter;} */@font-face {    font-family: ZhuZiAYuanJWD;    src: url(https://npm.elemecdn.com/anzhiyu-blog@1.1.6/fonts/ZhuZiAWan.woff2);    font-display: swap;    font-weight: lighter;  }    div#menus {    font-family: "ZhuZiAYuanJWD";  }  h1#site-title {    font-family: ZhuZiAYuanJWD;    font-size: 3em !important;  }  a.article-title,  a.blog-slider__title,  a.categoryBar-list-link,  h1.post-title {    font-family: ZhuZiAYuanJWD;  }    .iconfont {    font-family: "iconfont" !important;    font-size: 3em;    /* 可以定义图标大小 */    font-style: normal;    -webkit-font-smoothing: antialiased;    -moz-osx-font-smoothing: grayscale;  }    /* 时间轴生肖icon */  svg.icon {    /* 这里定义svg.icon，避免和Butterfly自带的note标签冲突 */    width: 1em;    height: 1em;    /* width和height定义图标的默认宽度和高度*/    vertical-align: -0.15em;    fill: currentColor;    overflow: hidden;  }    .icon-zhongbiao::before {    color: #f7c768;  }    /* bilibli番剧插件 */  #article-container .bangumi-tab.bangumi-active {    background: var(--anzhiyu-theme);    color: var(--anzhiyu-ahoverbg);    border-radius: 10px;  }  a.bangumi-tab:hover {    text-decoration: none !important;  }  .bangumi-button:hover {    background: var(--anzhiyu-theme) !important;    border-radius: 10px !important;    color: var(--anzhiyu-ahoverbg) !important;  }  a.bangumi-button.bangumi-nextpage:hover {    text-decoration: none !important;  }  .bangumi-button {    padding: 5px 10px !important;  }    a.bangumi-tab {    padding: 5px 10px !important;  }  svg.icon.faa-tada {    font-size: 1.1em;  }  .bangumi-info-item {    border-right: 1px solid #f2b94b;  }  .bangumi-info-item span {    color: #f2b94b;  }  .bangumi-info-item em {    color: #f2b94b;  }    /* 解决artitalk的图标问题 */  #uploadSource > svg {    width: 1.19em;    height: 1.5em;  }    /*top-img黑色透明玻璃效果移除，不建议加，除非你执着于完全一图流或者背景图对比色明显 */  #page-header:not(.not-top-img):before {    background-color: transparent !important;  }    /* 首页文章卡片 */  #recent-posts > .recent-post-item {    background: rgba(255, 255, 255, 0.9);  }    /* 首页侧栏卡片 */  #aside-content .card-widget {    background: rgba(255, 255, 255, 0.9);  }    /* 文章页面正文背景 */  div#post {    background: rgba(255, 255, 255, 0.9);  }    /* 分页页面 */  div#page {    background: rgba(255, 255, 255, 0.9);  }    /* 归档页面 */  div#archive {    background: rgba(255, 255, 255, 0.9);  }    /* 标签页面 */  div#tag {    background: rgba(255, 255, 255, 0.9);  }    /* 分类页面 */  div#category {    background: rgba(255, 255, 255, 0.9);  }    /*夜间模式伪类遮罩层透明*/  [data-theme="dark"] #recent-posts > .recent-post-item {    background: #121212;  }    [data-theme="dark"] .card-widget {    background: #121212 !important;  }    [data-theme="dark"] div#post {    background: #121212 !important;  }    [data-theme="dark"] div#tag {    background: #121212 !important;  }    [data-theme="dark"] div#archive {    background: #121212 !important;  }    [data-theme="dark"] div#page {    background: #121212 !important;  }    [data-theme="dark"] div#category {    background: #121212 !important;  }    [data-theme="dark"] div#category {    background: transparent !important;  }  /* 页脚透明 */  #footer {    background: transparent !important;  }    /* 头图透明 */  #page-header {    background: transparent !important;  }  #rightside > div > button {    border-radius: 5px;  }    /* 滚动条 */    ::-webkit-scrollbar {    width: 10px;    height: 10px;  }    ::-webkit-scrollbar-thumb {    background-color: #3b70fc;    border-radius: 2em;  }    ::-webkit-scrollbar-corner {    background-color: transparent;  }    ::-moz-selection {    color: #fff;    background-color: #3b70fc;  }    /* 音乐播放器 */    /* .aplayer .aplayer-lrc {    display: none !important;  } */    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body {    left: -66px !important;    transition: all 0.3s;    /* 默认情况下缩进左侧66px，只留一点箭头部分 */  }    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body:hover {    left: 0 !important;    transition: all 0.3s;    /* 鼠标悬停是左侧缩进归零，完全显示按钮 */  }    .aplayer.aplayer-fixed {    z-index: 999999 !important;  }    /* 评论框  */  .vwrap {    box-shadow: 2px 2px 5px #bbb;    background: rgba(255, 255, 255, 0.3);    border-radius: 8px;    padding: 30px;    margin: 30px 0px 30px 0px;  }    /* 设置评论框 */    .vcard {    box-shadow: 2px 2px 5px #bbb;    background: rgba(255, 255, 255, 0.3);    border-radius: 8px;    padding: 30px;    margin: 30px 0px 0px 0px;  }    /* md网站下划线 */  #article-container a:hover {    text-decoration: none !important;  }    #article-container #hpp_talk p img {    display: inline;  }    /* 404页面 */  #error-wrap {    position: absolute;    top: 40%;    right: 0;    left: 0;    margin: 0 auto;    padding: 0 1rem;    max-width: 1000px;    transform: translate(0, -50%);  }    #error-wrap .error-content {    display: flex;    flex-direction: row;    justify-content: center;    align-items: center;    margin: 0 1rem;    height: 18rem;    border-radius: 8px;    background: var(--card-bg);    box-shadow: var(--card-box-shadow);    transition: all 0.3s;  }    #error-wrap .error-content .error-img {    box-flex: 1;    flex: 1;    height: 100%;    border-top-left-radius: 8px;    border-bottom-left-radius: 8px;    background-color: #3b70fc;    background-position: center;    background-size: cover;  }    #error-wrap .error-content .error-info {    box-flex: 1;    flex: 1;    padding: 0.5rem;    text-align: center;    font-size: 14px;    font-family: Titillium Web, "PingFang SC", "Hiragino Sans GB", "Microsoft JhengHei", "Microsoft YaHei", sans-serif;  }  #error-wrap .error-content .error-info .error_title {    margin-top: -4rem;    font-size: 9em;  }  #error-wrap .error-content .error-info .error_subtitle {    margin-top: -3.5rem;    word-break: break-word;    font-size: 1.6em;  }  #error-wrap .error-content .error-info a {    display: inline-block;    margin-top: 0.5rem;    padding: 0.3rem 1.5rem;    background: var(--btn-bg);    color: var(--btn-color);  }    #body-wrap.error .aside-list {    display: flex;    flex-direction: row;    flex-wrap: nowrap;    bottom: 0px;    position: absolute;    padding: 1rem;    width: 100%;    overflow: scroll;  }    #body-wrap.error .aside-list .aside-list-group {    display: flex;    flex-direction: row;    flex-wrap: nowrap;    max-width: 1200px;    margin: 0 auto;  }    #body-wrap.error .aside-list .aside-list-item {    padding: 0.5rem;  }    #body-wrap.error .aside-list .aside-list-item img {    width: 100%;    object-fit: cover;    border-radius: 12px;  }    #body-wrap.error .aside-list .aside-list-item .thumbnail {    overflow: hidden;    width: 230px;    height: 143px;    background: var(--anzhiyu-card-bg);    display: flex;  }    #body-wrap.error .aside-list .aside-list-item .content .title {    -webkit-line-clamp: 2;    overflow: hidden;    display: -webkit-box;    -webkit-box-orient: vertical;    line-height: 1.5;    justify-content: center;    align-items: flex-end;    align-content: center;    padding-top: 0.5rem;    color: white;  }    #body-wrap.error .aside-list .aside-list-item .content time {    display: none;  }    /* 代码框主题 */  #article-container figure.highlight {    border-radius: 10px;  }]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>分类</title>
      <link href="/categories/index.html"/>
      <url>/categories/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/js/ali_font.js"/>
      <url>/js/ali_font.js</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
  
</search>
