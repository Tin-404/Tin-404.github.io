<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>排序算法</title>
      <link href="/posts/735e5788.html"/>
      <url>/posts/735e5788.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>贪心算法</title>
      <link href="/posts/a4ce31d2.html"/>
      <url>/posts/a4ce31d2.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>回溯算法</title>
      <link href="/posts/376d0826.html"/>
      <url>/posts/376d0826.html</url>
      
        <content type="html"><![CDATA[<h1 id="回溯算法"><a href="#回溯算法" class="headerlink" title="回溯算法"></a>回溯算法</h1>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>二叉树</title>
      <link href="/posts/e85d694a.html"/>
      <url>/posts/e85d694a.html</url>
      
        <content type="html"><![CDATA[<h1 id="二叉树的基本理论"><a href="#二叉树的基本理论" class="headerlink" title="二叉树的基本理论"></a>二叉树的基本理论</h1><h2 id="从二叉树的总类"><a href="#从二叉树的总类" class="headerlink" title="从二叉树的总类"></a>从二叉树的总类</h2><p>特殊的二叉树主要有两种：满二叉树和完全二叉树</p><h3 id="满二叉树"><a href="#满二叉树" class="headerlink" title="满二叉树"></a>满二叉树</h3><p>满二叉树：二叉树只有结点为0的结点和度为2的结点，并且度为0的结点在同一层上<br>如下图<br><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20200806185805576.png" alt="满二叉树"><br>这棵树为满二叉树，深度为k时，有2^k-1个结点</p><h3 id="完全二叉树"><a href="#完全二叉树" class="headerlink" title="完全二叉树"></a>完全二叉树</h3><p>完全二叉树：出来最底层结点没有被填满外，其余层结点数都达到最大，且最下面一层结点是从最左边连续<br>最底层有1~2^(k-1)个结点<br><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20200920221638903.png" alt="完全二叉树"><br>优先级队列其实就是一个堆，堆就是一颗完全二叉树，同时保证父子结点的顺序关系</p><h3 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h3><p>二叉搜索树是一棵中序遍历有序的树</p><ul><li>左子树上结点小于根结点值</li><li>右子树上结点大于根结点值<br><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20200806190304693.png" alt="二叉搜索树"><br>如上两个都是二叉搜索树</li></ul><h3 id="平衡二叉搜索树"><a href="#平衡二叉搜索树" class="headerlink" title="平衡二叉搜索树"></a>平衡二叉搜索树</h3><p>平衡二叉搜索树: 也称AVL(Adelson-Velsky and Landis)树，它左右两个树的高度差绝对值不超过1，且左右两棵<br>子树都是平衡二叉树。n个结点的平衡二叉搜索树高度可保持在 O(logN)，搜索时间复杂度O(logN )<br><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20200806190511967.png" alt="平衡二叉搜索树"><br>最后一棵不是因为高度差绝对值超过了1.</p><p>java中map和set底层实现是红黑树，这个以后找个篇章特意写吧！</p><h2 id="二叉树的存储方式"><a href="#二叉树的存储方式" class="headerlink" title="二叉树的存储方式"></a>二叉树的存储方式</h2><blockquote><p>二叉树可以链式存储，也可以顺序存储。链式存储使用指针，顺序存储使用数组</p></blockquote><p><code>链式存储数据结构</code></p><pre><code>public class TreeNode &#123;    int val;    TreeNode left;    TreeNode right;    public TreeNode()&#123;    &#125;    public TreeNode(int val)&#123;        this.val = val;    &#125;    public TreeNode(int val,TreeNode left,TreeNode right)&#123;        this.val = val;        this.left = left;        this.right = right;    &#125;&#125;</code></pre><blockquote><p>当使用数组存储二叉树时，若父节点下标是i，则其左孩子下标为2i+1，右孩子为2i+2。</p></blockquote><p><code>在Java中输入数组使其构成树</code></p><pre><code>public class Solution &#123;    static class TreeNode&#123;        int val;        TreeNode left;        TreeNode right;        public TreeNode()&#123;&#125;        public TreeNode(int val)&#123;            this.val = val;            this.left = null;            this.right = null;        &#125;    &#125;    public static void main(String[] args) &#123;        int[] arr = new int[7];        Scanner in = new Scanner(System.in);        for (int i = 0;i &lt; arr.length;i++)&#123;            arr[i] = in.nextInt();        &#125;        Solution solution = new Solution();        TreeNode root = solution.constructBinaryTree(arr);        System.out.println(root.right.right.val);    &#125;    public TreeNode constructBinaryTree(final int[] arr)&#123;        // 初始树        List&lt;TreeNode&gt; treeNodeList = arr.length &gt; 0 ? new ArrayList&lt;&gt;(arr.length) : null;        TreeNode root = null;        // 给树各个结点赋值        for (int i = 0;i &lt; arr.length;i++)&#123;            TreeNode node = null;            if (arr[i] != -1)&#123;                node = new TreeNode(arr[i]);            &#125;            treeNodeList.add(node);            if (i == 0)&#123;                root = node;            &#125;        &#125;        // 指定树结点的左右孩子        for (int i = 0;i * 2 + 1&lt;arr.length;i++)&#123;            TreeNode node = treeNodeList.get(i);            if (node != null)&#123;                // 左孩子2i+1                node.left = treeNodeList.get(2 * i + 1);                // 右孩子2i+2                if (i * 2 + 2 &lt; arr.length)&#123;                    node.right = treeNodeList.get(2 * i + 2);                &#125;            &#125;        &#125;        return root;    &#125;&#125;</code></pre><h2 id="二叉树的遍历方式"><a href="#二叉树的遍历方式" class="headerlink" title="二叉树的遍历方式"></a>二叉树的遍历方式</h2><blockquote><p>二叉树主要有两种遍历方式：</p><ol><li>深度优先遍历：先往深走，遇到叶子结点再往回走<ul><li>前序遍历(递归法，迭代法)</li><li>中序遍历(递归法，迭代法)</li><li>后序遍历(递归法，迭代法)</li></ul></li><li>广度优先遍历：一层一层的去遍历<ul><li>层次遍历(递归法，迭代法)</li></ul></li></ol></blockquote><h3 id="二叉树的深度优先遍历"><a href="#二叉树的深度优先遍历" class="headerlink" title="二叉树的深度优先遍历"></a>二叉树的深度优先遍历</h3><blockquote><p>主要记录深度优先的递归法，迭代法可以借助栈来实现<br>在进行递归时也会使用到栈，但是这个栈是由内存自己为我们分配的</p><p>二叉树的前序遍历是从上往下的遍历方式</p></blockquote><p><code>前序遍历的递归法</code></p><pre><code>public List&lt;Integer&gt; preorderTraversal(TreeNode root)&#123;    List&lt;Integer&gt; res = new ArrayList&lt;&gt;();    preorder(root,res);    return res;&#125;public void preorder(TreeNode root,List&lt;Integer&gt; res)&#123;    if (root == null)&#123;        return;    &#125;    res.add(root.val);    preorder(root.left,res);    preorder(root.right,res);&#125;</code></pre><blockquote><p>二叉搜索树的中序遍历是有序的</p></blockquote><p><code>中序遍历的递归法</code></p><pre><code>public List&lt;Integer&gt; inorderTraversal(TreeNode root) &#123;    List&lt;Integer&gt; res = new ArrayList&lt;&gt;();    inorder(root, res);    return res;&#125;public void inorder(TreeNode root, List&lt;Integer&gt; res) &#123;    if (root == null) &#123;        return;    &#125;    inorder(root.left, res);    res.add(root.val);    inorder(root.right, res);&#125;</code></pre><blockquote><p>二叉树的后序遍历是从下往上的遍历方式</p></blockquote><p><code>后序遍历的递归法</code></p><pre><code>public List&lt;Integer&gt; postorderTraversal(TreeNode root) &#123;    List&lt;Integer&gt; res = new ArrayList&lt;&gt;();    postorder(root, res);    return res;&#125;public void postorder(TreeNode root, List&lt;Integer&gt; res) &#123;    if (root == null) &#123;        return;    &#125;    preorder(root.left, res);    preorder(root.right, res);    res.add(root.val);&#125;</code></pre><h3 id="二叉树的广度优先遍历"><a href="#二叉树的广度优先遍历" class="headerlink" title="二叉树的广度优先遍历"></a>二叉树的广度优先遍历</h3><blockquote><p>广度优先遍历也可使用递归法与迭代法<br>递归法是每一层作为一个递归<br>迭代法则是借助队列</p></blockquote><p><code>二叉树的广度优先遍历</code></p><pre><code>List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;    levelOne(root, 0);    levelTwo(root);    return res;&#125;// 递归法public void levelOne(TreeNode root, int depth) &#123;    if (root == null) &#123;        return;    &#125;    depth++;    if (res.size() &lt; depth) &#123;        List&lt;Integer&gt; item = new ArrayList&lt;&gt;();        res.add(item);    &#125;    res.get(depth - 1).add(root.val);    levelOne(root.left, depth);    levelOne(root.right, depth);&#125;// 迭代法，借助队列public void levelTwo(TreeNode root) &#123;    if (root == null) &#123;        return;    &#125;    Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;();    queue.offer(root);    while (!queue.isEmpty()) &#123;        List&lt;Integer&gt; item = new ArrayList&lt;&gt;();        int len = queue.size();        while (len &gt; 0) &#123;            TreeNode temp = queue.poll();            item.add(temp.val);            if (temp.left != null) &#123;                queue.offer(temp.left);            &#125;            if (temp.right != null) &#123;                queue.offer(temp.right);            &#125;            len--;        &#125;        res.add(item);    &#125;&#125;</code></pre><blockquote><p>对于二叉树的相关特征以及算法主要有以下</p></blockquote><h2 id="二叉树的属性"><a href="#二叉树的属性" class="headerlink" title="二叉树的属性"></a>二叉树的属性</h2><h3 id="1-二叉树是否对称-101-对称二叉树"><a href="#1-二叉树是否对称-101-对称二叉树" class="headerlink" title="(1)二叉树是否对称:101.对称二叉树"></a><a href="https://leetcode.cn/problems/symmetric-tree/">(1)二叉树是否对称:101.对称二叉树</a></h3><p>给定一个二叉树，判断其是不是对称的，如下图<br><img src="https://assets.leetcode.com/uploads/2021/02/19/symtree1.jpg" alt="二叉树"></p><blockquote><p>判断一棵树是不是轴对称，既是判断根节点的左子树和右子树是不是翻转的，也就是左的左是否等于右的右，<br>左的右是不是等于右的左，使用递归对每个结点进行判断；<br>也可以借助队列，将左右结点按照顺序放入队列中进行比较。</p></blockquote><p><code>递归法</code></p><pre><code>public boolean isSymmetric(TreeNode root) &#123;    return compare(root.left,root.right);&#125;public boolean compare(TreeNode left,TreeNode right)&#123;    if (left == null &amp;&amp; right != null)&#123;        return false;    &#125;    if (left != null &amp;&amp; right == null)&#123;        return false;    &#125;    if (left == null &amp;&amp; right == null)&#123;        return true;    &#125;    if (left.val != right.val)&#123;        return false;    &#125;    // 比较外侧    boolean outside = compare(left.left,right.right);    // 比较内侧    boolean inside = compare(left.right,right.left);    return outside &amp;&amp; inside;&#125;</code></pre><p><code>迭代法</code></p><pre><code>public boolean isSymmetric(TreeNode root) &#123;    Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;();    queue.offer(root.left);    queue.offer(root.right);    while (!queue.isEmpty())&#123;        TreeNode left = queue.poll();        TreeNode right = queue.poll();        if (left == null &amp;&amp; right == null)&#123;            continue;        &#125;        if (left == null || right == null || left.val != right.val)&#123;            return false;        &#125;        // 按照左左，右右，左右，右左顺序加入队列        queue.offer(left.left);        queue.offer(right.right);        queue.offer(left.right);        queue.offer(right.left);    &#125;    return true;&#125;</code></pre><h3 id="2-求二叉树的最大深度和最小深度"><a href="#2-求二叉树的最大深度和最小深度" class="headerlink" title="(2)求二叉树的最大深度和最小深度"></a>(2)求二叉树的最大深度和最小深度</h3><p><a href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/">最大深度</a><br><a href="https://leetcode.cn/problems/minimum-depth-of-binary-tree/">最小深度</a></p><blockquote><p>求最大深度，通过递归法，递归返回的值即是树的深度，也可以同迭代法进行层序遍历，每遍历一层将depth++；<br>求最小深度，通过递归法，找到第一个左右结点都为空的结点即为最小深度结点；通过迭代法进行层序遍历，第一个左右结点都为空<br>的结点即为最小深度结点。</p></blockquote><p><code>最大深度递归法</code></p><pre><code>public int maxDepth(TreeNode root) &#123;    if (root == null) &#123;        return 0;    &#125; else &#123;        int left = maxDepth(root.left);        int right = maxDepth(root.right);        return Math.max(left, right) + 1;    &#125; &#125;</code></pre><p><code>最大深度迭代法</code></p><pre><code>public int maxDepth(TreeNode root) &#123;    if (root == null)&#123;        return 0;    &#125;    Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;();    queue.offer(root);    int deep = 0;    while (!queue.isEmpty())&#123;        int len = queue.size();        while (len &gt; 0)&#123;            TreeNode temp = queue.poll();            if (temp.left != null)&#123;                queue.offer(temp.left);            &#125;            if (temp.right != null) &#123;                queue.offer(temp.right);            &#125;            len--;        &#125;        // 借助队列，没迭代一层之后深度++；        deep++;    &#125;    return deep;&#125;</code></pre><p><code>最小深度递归法</code></p><pre><code>public int minDepth(TreeNode root) &#123;    if (root == null) &#123;        return 0;    &#125;    int leftDepth = minDepth(root.left);    int rightDepth = minDepth(root.right);    if (root.left == null) &#123;        return rightDepth + 1;    &#125;    if (root.right == null) &#123;        return leftDepth + 1;    &#125;    // 左右结点都不为null    return Math.min(leftDepth, rightDepth) + 1;&#125;</code></pre><p><code>最小深度迭代法</code></p><pre><code>public int minDepth(TreeNode root) &#123;    if(root == null)&#123;        return 0;    &#125;    Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;();    queue.offer(root);    int depth = 0;    while (!queue.isEmpty())&#123;        int len = queue.size();        depth++;        TreeNode temp = null;        while (len &gt; 0)&#123;            temp = queue.poll();            // 当遇到第一个左右结点都为空的直接返回。            if (temp.left == null &amp;&amp; temp.right==null)&#123;                return depth;            &#125;            if (temp.left != null)&#123;                queue.offer(temp.left);            &#125;            if (temp.right != null)&#123;                queue.offer(temp.right);            &#125;            len--;        &#125;    &#125;    return depth;&#125;</code></pre><h3 id="3-求二叉树结点个数"><a href="#3-求二叉树结点个数" class="headerlink" title="(3)求二叉树结点个数"></a><a href="https://leetcode.cn/problems/count-complete-tree-nodes/">(3)求二叉树结点个数</a></h3><blockquote><p>直接通过递归法，递归次数即为结点个数<br>也可以借助队列，队列中每加入一个结点，则结点总个数++</p></blockquote><p><code>递归法</code></p><pre><code>public int countNodes(TreeNode root) &#123;    if (root == null)&#123;        return 0;    &#125;    return countNodes(root.left) + countNodes(root.right) + 1;&#125;</code></pre><p><code>迭代法</code></p><pre><code>public int countNodes(TreeNode root) &#123;    if (root == null)&#123;        return 0;    &#125;    Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;();    queue.offer(root);    int result = 0;    while (!queue.isEmpty())&#123;        int len = queue.size();        while (len &gt; 0)&#123;            TreeNode temp = queue.poll();            // 统计结点个数            result++;            if (temp.left != null)&#123;                queue.offer(temp.left);            &#125;            if (temp.right != null)&#123;                queue.offer(temp.right);            &#125;            len--;        &#125;    &#125;    return result;&#125;</code></pre><h3 id="4-二叉树是否平衡"><a href="#4-二叉树是否平衡" class="headerlink" title="(4)二叉树是否平衡"></a><a href="https://leetcode.cn/problems/balanced-binary-tree/">(4)二叉树是否平衡</a></h3><blockquote><p>判断二叉树是否平衡即每一个结点都需要进行判断，对每一个结点进行左右子树高度比较，所以我们可以通过<br>后序遍历来做,使用-1做为不平衡的标志</p></blockquote><p><code>递归后序遍历</code></p><pre><code>public boolean isBalanced(TreeNode root) &#123;    return getHeight(root) != -1;&#125;private int getHeight(TreeNode root) &#123;    if (root == null) &#123;        return 0;    &#125;    int leftHeight = getHeight(root.left);    if (leftHeight == -1) &#123;        return -1;    &#125;    int rightHeight = getHeight(root.right);    if (rightHeight == -1) &#123;        return -1;    &#125;    // 左右子树高度差大于1，return -1表示已经不是平衡树了    if (Math.abs(leftHeight - rightHeight) &gt; 1) &#123;        return -1;    &#125;    return Math.max(leftHeight, rightHeight) + 1;&#125;</code></pre><h3 id="5-求所有路径"><a href="#5-求所有路径" class="headerlink" title="(5)求所有路径"></a><a href="https://leetcode.cn/problems/binary-tree-paths/">(5)求所有路径</a></h3><blockquote><p>求根节点到所有叶子结点的路径，可以很简单的使用深度优先遍历直到叶子结点<br>使用前序遍历使父节点指向子节点，直到子节点的左右孩子都为空<br>也可以使用迭代法，借助栈，非空时一直往站内添加元素</p></blockquote><p><code>递归法</code></p><pre><code>public List&lt;String&gt; binaryTreePaths(TreeNode root) &#123;    List&lt;String&gt; res = new ArrayList&lt;&gt;();    if (root == null)&#123;        return res;    &#125;    dfs(root,&quot;&quot;,res);    return res;&#125;public void dfs(TreeNode node,String path,List&lt;String&gt; res)&#123;    if (node != null)&#123;        StringBuffer sb = new StringBuffer(path);        sb.append(Integer.toString(node.val));        if (node.left == null &amp;&amp; node.right==null)&#123;            res.add(sb.toString());        &#125; else &#123;          sb.append(&quot;-&gt;&quot;);          dfs(node.left,sb.toString(),res);          dfs(node.right,sb.toString(),res);        &#125;    &#125;&#125;</code></pre><p><code>迭代法</code></p><pre><code>public List&lt;String&gt; binaryTreePaths(TreeNode root) &#123;    if (root == null)&#123;        return null;    &#125;    List&lt;String&gt; res = new ArrayList&lt;&gt;();    Stack&lt;Object&gt; stack = new Stack&lt;&gt;();    // 节点和路径同时入栈    stack.push(root);    stack.push(root.val + &quot;&quot;);    while (!stack.isEmpty())&#123;        // 节点和路径同时出栈        String path = (String) stack.pop();        TreeNode node = (TreeNode) stack.pop();        // 若找到叶子节点        if (node.left == null &amp;&amp; node.right==null)&#123;            res.add(path);        &#125;        //右子节点不为空        if (node.right!=null)&#123;            stack.push(node.right);            stack.push(path + &quot;-&gt;&quot; + node.right.val);        &#125;        //左子节点不为空        if (node.left != null)&#123;            stack.push(node.left);            stack.push(path + &quot;-&gt;&quot; + node.left.val);        &#125;    &#125;    return res;&#125;</code></pre><h3 id="6-求左叶子的和"><a href="#6-求左叶子的和" class="headerlink" title="[(6)求左叶子的和]"></a>[(6)求左叶子的和]</h3><h3 id="7-求左下角的值"><a href="#7-求左下角的值" class="headerlink" title="[(7)求左下角的值]"></a>[(7)求左下角的值]</h3><h3 id="8-求路径总和"><a href="#8-求路径总和" class="headerlink" title="[(8)求路径总和]"></a>[(8)求路径总和]</h3><h2 id="二叉树的修改与改造"><a href="#二叉树的修改与改造" class="headerlink" title="二叉树的修改与改造"></a>二叉树的修改与改造</h2><h2 id="二叉搜索树的属性"><a href="#二叉搜索树的属性" class="headerlink" title="二叉搜索树的属性"></a>二叉搜索树的属性</h2><h2 id="二叉树公共祖先问题"><a href="#二叉树公共祖先问题" class="headerlink" title="二叉树公共祖先问题"></a>二叉树公共祖先问题</h2><h2 id="二叉搜索树的修改与改造"><a href="#二叉搜索树的修改与改造" class="headerlink" title="二叉搜索树的修改与改造"></a>二叉搜索树的修改与改造</h2>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>开始</title>
      <link href="/posts/0.html"/>
      <url>/posts/0.html</url>
      
        <content type="html"><![CDATA[<h1 id="记录"><a href="#记录" class="headerlink" title="记录"></a>记录</h1><div class="tip info"><ul><li>无回顾，不成长 </li></ul></div><h1 id="…"><a href="#…" class="headerlink" title="…"></a>…</h1><h1 id="123"><a href="#123" class="headerlink" title="123"></a>123</h1>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/posts/16107.html"/>
      <url>/posts/16107.html</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title></title>
      <link href="/manifest.json"/>
      <url>/manifest.json</url>
      
        <content type="html"><![CDATA[{"name":"LIFE","short_name":"WENJD","theme_color":"#3b70fc","background_color":"#3b70fc","display":"standalone","scope":"/","start_url":"/","icons":[{"src":"/img/siteicon/16.png","sizes":"16x16","type":"image/png"},{"src":"/img/siteicon/32.png","sizes":"32x32","type":"image/png"},{"src":"/img/siteicon/48.png","sizes":"48x48","type":"image/png"},{"src":"/img/siteicon/64.png","sizes":"64x64","type":"image/png"},{"src":"/img/siteicon/128.png","sizes":"128x128","type":"image/png"},{"src":"/img/siteicon/144.png","sizes":"144x144","type":"image/png"},{"src":"/img/siteicon/512.png","sizes":"512x512","type":"image/png"}],"splash_pages":null}]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/css/custom.css"/>
      <url>/css/custom.css</url>
      
        <content type="html"><![CDATA[/* @font-face {  font-family: Candyhome;  src: url(https://npm.elemecdn.com/anzhiyu-blog@1.1.6/fonts/Candyhome.ttf);  font-display: swap;  font-weight: lighter;} */@font-face {    font-family: ZhuZiAYuanJWD;    src: url(https://npm.elemecdn.com/anzhiyu-blog@1.1.6/fonts/ZhuZiAWan.woff2);    font-display: swap;    font-weight: lighter;  }    div#menus {    font-family: "ZhuZiAYuanJWD";  }  h1#site-title {    font-family: ZhuZiAYuanJWD;    font-size: 3em !important;  }  a.article-title,  a.blog-slider__title,  a.categoryBar-list-link,  h1.post-title {    font-family: ZhuZiAYuanJWD;  }    .iconfont {    font-family: "iconfont" !important;    font-size: 3em;    /* 可以定义图标大小 */    font-style: normal;    -webkit-font-smoothing: antialiased;    -moz-osx-font-smoothing: grayscale;  }    /* 时间轴生肖icon */  svg.icon {    /* 这里定义svg.icon，避免和Butterfly自带的note标签冲突 */    width: 1em;    height: 1em;    /* width和height定义图标的默认宽度和高度*/    vertical-align: -0.15em;    fill: currentColor;    overflow: hidden;  }    .icon-zhongbiao::before {    color: #f7c768;  }    /* bilibli番剧插件 */  #article-container .bangumi-tab.bangumi-active {    background: var(--anzhiyu-theme);    color: var(--anzhiyu-ahoverbg);    border-radius: 10px;  }  a.bangumi-tab:hover {    text-decoration: none !important;  }  .bangumi-button:hover {    background: var(--anzhiyu-theme) !important;    border-radius: 10px !important;    color: var(--anzhiyu-ahoverbg) !important;  }  a.bangumi-button.bangumi-nextpage:hover {    text-decoration: none !important;  }  .bangumi-button {    padding: 5px 10px !important;  }    a.bangumi-tab {    padding: 5px 10px !important;  }  svg.icon.faa-tada {    font-size: 1.1em;  }  .bangumi-info-item {    border-right: 1px solid #f2b94b;  }  .bangumi-info-item span {    color: #f2b94b;  }  .bangumi-info-item em {    color: #f2b94b;  }    /* 解决artitalk的图标问题 */  #uploadSource > svg {    width: 1.19em;    height: 1.5em;  }    /*top-img黑色透明玻璃效果移除，不建议加，除非你执着于完全一图流或者背景图对比色明显 */  #page-header:not(.not-top-img):before {    background-color: transparent !important;  }    /* 首页文章卡片 */  #recent-posts > .recent-post-item {    background: rgba(255, 255, 255, 0.9);  }    /* 首页侧栏卡片 */  #aside-content .card-widget {    background: rgba(255, 255, 255, 0.9);  }    /* 文章页面正文背景 */  div#post {    background: rgba(255, 255, 255, 0.9);  }    /* 分页页面 */  div#page {    background: rgba(255, 255, 255, 0.9);  }    /* 归档页面 */  div#archive {    background: rgba(255, 255, 255, 0.9);  }    /* 标签页面 */  div#tag {    background: rgba(255, 255, 255, 0.9);  }    /* 分类页面 */  div#category {    background: rgba(255, 255, 255, 0.9);  }    /*夜间模式伪类遮罩层透明*/  [data-theme="dark"] #recent-posts > .recent-post-item {    background: #121212;  }    [data-theme="dark"] .card-widget {    background: #121212 !important;  }    [data-theme="dark"] div#post {    background: #121212 !important;  }    [data-theme="dark"] div#tag {    background: #121212 !important;  }    [data-theme="dark"] div#archive {    background: #121212 !important;  }    [data-theme="dark"] div#page {    background: #121212 !important;  }    [data-theme="dark"] div#category {    background: #121212 !important;  }    [data-theme="dark"] div#category {    background: transparent !important;  }  /* 页脚透明 */  #footer {    background: transparent !important;  }    /* 头图透明 */  #page-header {    background: transparent !important;  }  #rightside > div > button {    border-radius: 5px;  }    /* 滚动条 */    ::-webkit-scrollbar {    width: 10px;    height: 10px;  }    ::-webkit-scrollbar-thumb {    background-color: #3b70fc;    border-radius: 2em;  }    ::-webkit-scrollbar-corner {    background-color: transparent;  }    ::-moz-selection {    color: #fff;    background-color: #3b70fc;  }    /* 音乐播放器 */    /* .aplayer .aplayer-lrc {    display: none !important;  } */    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body {    left: -66px !important;    transition: all 0.3s;    /* 默认情况下缩进左侧66px，只留一点箭头部分 */  }    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body:hover {    left: 0 !important;    transition: all 0.3s;    /* 鼠标悬停是左侧缩进归零，完全显示按钮 */  }    .aplayer.aplayer-fixed {    z-index: 999999 !important;  }    /* 评论框  */  .vwrap {    box-shadow: 2px 2px 5px #bbb;    background: rgba(255, 255, 255, 0.3);    border-radius: 8px;    padding: 30px;    margin: 30px 0px 30px 0px;  }    /* 设置评论框 */    .vcard {    box-shadow: 2px 2px 5px #bbb;    background: rgba(255, 255, 255, 0.3);    border-radius: 8px;    padding: 30px;    margin: 30px 0px 0px 0px;  }    /* md网站下划线 */  #article-container a:hover {    text-decoration: none !important;  }    #article-container #hpp_talk p img {    display: inline;  }    /* 404页面 */  #error-wrap {    position: absolute;    top: 40%;    right: 0;    left: 0;    margin: 0 auto;    padding: 0 1rem;    max-width: 1000px;    transform: translate(0, -50%);  }    #error-wrap .error-content {    display: flex;    flex-direction: row;    justify-content: center;    align-items: center;    margin: 0 1rem;    height: 18rem;    border-radius: 8px;    background: var(--card-bg);    box-shadow: var(--card-box-shadow);    transition: all 0.3s;  }    #error-wrap .error-content .error-img {    box-flex: 1;    flex: 1;    height: 100%;    border-top-left-radius: 8px;    border-bottom-left-radius: 8px;    background-color: #3b70fc;    background-position: center;    background-size: cover;  }    #error-wrap .error-content .error-info {    box-flex: 1;    flex: 1;    padding: 0.5rem;    text-align: center;    font-size: 14px;    font-family: Titillium Web, "PingFang SC", "Hiragino Sans GB", "Microsoft JhengHei", "Microsoft YaHei", sans-serif;  }  #error-wrap .error-content .error-info .error_title {    margin-top: -4rem;    font-size: 9em;  }  #error-wrap .error-content .error-info .error_subtitle {    margin-top: -3.5rem;    word-break: break-word;    font-size: 1.6em;  }  #error-wrap .error-content .error-info a {    display: inline-block;    margin-top: 0.5rem;    padding: 0.3rem 1.5rem;    background: var(--btn-bg);    color: var(--btn-color);  }    #body-wrap.error .aside-list {    display: flex;    flex-direction: row;    flex-wrap: nowrap;    bottom: 0px;    position: absolute;    padding: 1rem;    width: 100%;    overflow: scroll;  }    #body-wrap.error .aside-list .aside-list-group {    display: flex;    flex-direction: row;    flex-wrap: nowrap;    max-width: 1200px;    margin: 0 auto;  }    #body-wrap.error .aside-list .aside-list-item {    padding: 0.5rem;  }    #body-wrap.error .aside-list .aside-list-item img {    width: 100%;    object-fit: cover;    border-radius: 12px;  }    #body-wrap.error .aside-list .aside-list-item .thumbnail {    overflow: hidden;    width: 230px;    height: 143px;    background: var(--anzhiyu-card-bg);    display: flex;  }    #body-wrap.error .aside-list .aside-list-item .content .title {    -webkit-line-clamp: 2;    overflow: hidden;    display: -webkit-box;    -webkit-box-orient: vertical;    line-height: 1.5;    justify-content: center;    align-items: flex-end;    align-content: center;    padding-top: 0.5rem;    color: white;  }    #body-wrap.error .aside-list .aside-list-item .content time {    display: none;  }    /* 代码框主题 */  #article-container figure.highlight {    border-radius: 10px;  }]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/js/ali_font.js"/>
      <url>/js/ali_font.js</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
  
</search>
