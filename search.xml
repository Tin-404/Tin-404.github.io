<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>数据结构与算法学习</title>
      <link href="/posts/41534dc1.html"/>
      <url>/posts/41534dc1.html</url>
      
        <content type="html"><![CDATA[<h1 id="数据结构与算法"><a href="#数据结构与算法" class="headerlink" title="数据结构与算法"></a>数据结构与算法</h1><h2 id="初识算法"><a href="#初识算法" class="headerlink" title="初识算法"></a>初识算法</h2><h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><p><strong>算法Algorithm</strong>是在有限时间内解决特定问题的一组指令或操作步骤</p><ul><li>明确性：清晰输入输出</li><li>可行性：有限步骤、时间和内存空间下完成</li><li>结果确定性：相同的输入和运行下，输出相同</li></ul><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p><strong>数据结构 Data Structure</strong>计算机组织和存储数据的方式</p><ul><li>空间占用尽量减少，节省计算机内存</li><li>数据操作尽可能快速，涵盖数据访问、添加、删除、更新等</li><li>提供简洁的数据表示和逻辑信息，以便使得算法高效运行</li></ul><h3 id="数据结构与算法关系"><a href="#数据结构与算法关系" class="headerlink" title="数据结构与算法关系"></a>数据结构与算法关系</h3><ul><li>数据结构是算法的基石。数据结构为算法提供结构化存储的数据，以及用于操作数据的方法</li><li>算法对数据结构结构化存储的数据进行操作。数据结构本身仅存储数据信息，需要结合算法才能解决特定问题</li><li>特定算法通常有对应最优的数据结构。算法通常可以基于不同的数据结构进行实现，但最终执行效率可能相差很大<br><img src="https://www.hello-algo.com/chapter_introduction/what_is_dsa.assets/relationship_between_data_structure_and_algorithm.png" alt="数据结构与算法关系"></li></ul><p><code>数据结构就类似于积木组织形成，包括形状、大小、连接方式等。算法就是把积木拼成最终形态的一系列操作步骤。</code><br><code>积木对应于数据，积木形状和连接方式代表数据结构，拼装积木的步骤则对应算法</code></p><p><br></p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>算法设计追求层面</p><ol><li><strong>找到问题解法：</strong>算法需要在规定的输入范围内，可靠的求得问题的正确解</li><li><strong>寻找最优解法：</strong>同一个问题可能存在多种解法，我们希望能够找到尽可能高效的算法</li></ol><p>在解决问题的前提下，算法效率成为主要评价维度：</p><ul><li>时间效率</li><li>空间效率</li></ul><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p><strong>常见类型</strong><br>O(1) &lt; O(\log n) &lt; O(n) &lt; O(n \log n) &lt; O(n^2) &lt; O(2^n) &lt; O(n!)<br>{常数阶} &lt; {对数阶} &lt; {线性阶} &lt; {线性对数阶} &lt; {平方阶} &lt; {指数阶} &lt; {阶乘阶}</p><ul><li>常数阶（O(1)）<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 常数阶 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">constant</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">100000</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">        count++;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>线性阶（O(n)）<br>线性阶的操作数量相对于输入数据大小以线性级别增长。线性阶通常出现在<code>单层循环</code>中<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 线性阶 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">linear</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        count++;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 线性阶（遍历数组） */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">arrayTraversal</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 循环次数与数组长度成正比</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>平方阶（O(n^2)）<br>平方阶的操作数量相对于输入数据大小以平方级别增长。平方阶通常出现在<strong>嵌套循环</strong>中，外层循环和内层循环都为 (O(n)) ，因此总体为 (O(n^2)) 。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 平方阶 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">quadratic</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 循环次数与数组长度成平方关系</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>以「冒泡排序」为例，外层循环执行 (n - 1) 次，内层循环执行 (n-1, n-2, …, 2, 1) 次，平均为 (\frac{n}{2}) 次，因此时间复杂度为 (O(n^2)) 。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 平方阶（冒泡排序） */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">bubbleSort</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 计数器</span></span><br><span class="line">    <span class="comment">// 外循环：未排序区间为 [0, i]</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> nums.length - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="comment">// 内循环：将未排序区间 [0, i] 中的最大元素交换至该区间的最右端 </span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[j] &gt; nums[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="comment">// 交换 nums[j] 与 nums[j + 1]</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> nums[j];</span><br><span class="line">                nums[j] = nums[j + <span class="number">1</span>];</span><br><span class="line">                nums[j + <span class="number">1</span>] = tmp;</span><br><span class="line">                count += <span class="number">3</span>; <span class="comment">// 元素交换包含 3 个单元操作</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>指数阶（O(2^N)）<br>生物学的“细胞分裂”是指数阶增长的典型例子：初始状态为 (1) 个细胞，分裂一轮后变为 (2) 个，分裂两轮后变为 (4) 个，以此类推，分裂 (n) 轮后有 (2^n) 个细胞。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 指数阶（循环实现） */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">exponential</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>, base = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 细胞每轮一分为二，形成数列 1, 2, 4, 8, ..., 2^(n-1)</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; base; j++) &#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        base *= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// count = 1 + 2 + 4 + 8 + .. + 2^(n-1) = 2^n - 1</span></span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在实际算法中，指数阶常出现于递归函数。例如以下代码，其递归地一分为二，经过 (n) 次分裂后停止。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 指数阶（递归实现） */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">expRecur</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> expRecur(n - <span class="number">1</span>) + expRecur(n - <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>指数阶增长非常迅速，在<strong>穷举法（暴力搜索、回溯等）</strong>中比较常见。对于数据规模较大的问题，指数阶是不可接受的，通常需要使用<strong>动态规划</strong>或<strong>贪心</strong>等算法来解决。</p></li><li><p>对数阶（O(logn)）<br>与指数阶相反，对数阶反映了“每轮缩减到一半”的情况。设输入数据大小为 (n) ，由于每轮缩减到一半，因此循环次数是 (log2n) ，即 (2^n) 的反函数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 对数阶（循环实现） */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">logarithmic</span><span class="params">(<span class="type">float</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (n &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        n = n / <span class="number">2</span>;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与指数阶类似，对数阶也常出现于递归函数。以下代码形成了一个高度为 (log2n) 的递归树。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 对数阶（递归实现） */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">logRecur</span><span class="params">(<span class="type">float</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> logRecur(n / <span class="number">2</span>) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>线性对数阶（O(n\logn)）<br>线性对数阶常出现于嵌套循环中，两层循环的时间复杂度分别为 (O(\log n)) 和 (O(n)) 。</p></li></ul><p>主流排序算法的时间复杂度通常为 (O(n \log n)) ，例如<strong>快速排序、归并排序、堆排序</strong>等。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 线性对数阶 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">linearLogRecur</span><span class="params">(<span class="type">float</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> linearLogRecur(n / <span class="number">2</span>) +</span><br><span class="line">            linearLogRecur(n / <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>阶乘阶（O(n!)）<br>阶乘通常使用<strong>递归实现</strong>。例如以下代码，第一层分裂出 (n) 个，第二层分裂出 (n - 1) 个，以此类推，直至第 (n) 层时终止分裂。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 阶乘阶（递归实现） */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">factorialRecur</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 从 1 个分裂出 n 个</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        count += factorialRecur(n - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h3><p>算法运行过程中使用的内存空间主要包括以下几种：</p><ul><li>输入空间：用于存储算法的输入数据。</li><li>暂存空间：用于存储算法运行过程中的变量、对象、函数上下文等数据。</li><li>输出空间：用于存储算法的输出数据。<br>一般情况下，空间复杂度的统计范围是<strong>暂存空间</strong>加上<strong>输出空间</strong>。</li></ul><p>暂存空间可以进一步划分为三个部分：</p><ul><li>暂存数据：用于保存算法运行过程中的各种常量、变量、对象等。</li><li>栈帧空间：用于保存调用函数的上下文数据。系统在每次调用函数时都会在栈顶部创建一个栈帧，函数返回后，栈帧空间会被释放。</li><li>指令空间：用于保存编译后的程序指令，在实际统计中通常忽略不计。<br>因此在分析一段程序的空间复杂度时，我们通常统计<strong>暂存数据、输出数据、栈帧空间</strong>三部分。<br><img src="https://www.hello-algo.com/chapter_computational_complexity/space_complexity.assets/space_types.png" alt="算法使用的相关空间"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 类 */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    Node next;</span><br><span class="line">    Node(<span class="type">int</span> x) &#123; val = x; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 函数 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">function</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// do something...</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">algorithm</span><span class="params">(<span class="type">int</span> n)</span> &#123;        <span class="comment">// 输入数据</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0</span>;          <span class="comment">// 暂存数据（常量）</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">0</span>;                <span class="comment">// 暂存数据（变量）</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="number">0</span>);  <span class="comment">// 暂存数据（对象）</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> function();       <span class="comment">// 栈帧空间（调用函数）</span></span><br><span class="line">    <span class="keyword">return</span> a + b + c;         <span class="comment">// 输出数据</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><code>我们通常只关注「最差空间复杂度」</code><br>常见的空间复杂度类型有（从低到高排列）：<br>O(1) &lt; O(\log n) &lt; O(n) &lt; O(n^2) &lt; O(2^n)<br>{常数阶} &lt; {对数阶} &lt; {线性阶} &lt; {平方阶} &lt; {指数阶} </li></ul><h3 id="数据结构-1"><a href="#数据结构-1" class="headerlink" title="数据结构"></a>数据结构</h3><h4 id="逻辑结构"><a href="#逻辑结构" class="headerlink" title="逻辑结构"></a>逻辑结构</h4><p><strong>逻辑结构</strong>是数据元素之间的逻辑关系</p><ul><li><strong>线性数据结构：</strong>数组、链表、栈、队列、哈希表</li><li><strong>非线性数据结构：</strong>树、堆、图、哈希表</li></ul><p><img src="https://www.hello-algo.com/chapter_data_structure/classification_of_data_structure.assets/classification_logic_structure.png" alt="线性与非线性数据结构"></p><p>非线性数据结构可以进一步被划分为树形结构与网状结构</p><ul><li><strong>线性结构：</strong>数组、链表、队列、栈、哈希表，元素存在一对一的顺序关系。</li><li><strong>树形结构：</strong>树、堆、哈希表，元素存在一对多的关系。</li><li><strong>网状结构：</strong>图，元素存在多对多的关系。</li></ul><p><br></p><ul><li>基于数组可实现：栈、队列、哈希表、树、堆、图、矩阵等。</li><li>基于链表可实现：栈、队列、哈希表、树、堆、图等。</li></ul><h3 id="数字编码"><a href="#数字编码" class="headerlink" title="数字编码"></a>数字编码</h3><h4 id="原码，反码，补码"><a href="#原码，反码，补码" class="headerlink" title="原码，反码，补码"></a>原码，反码，补码</h4><ul><li><strong>原码：</strong>我们将数字的二进制表示的最高位视为符号位，其中 (0) 表示正数，(1) 表示负数，其余位表示数字的值。</li><li><strong>反码：</strong>正数的反码与其原码相同，负数的反码是对其原码除符号位外的所有位取反。</li><li><strong>补码：</strong>正数的补码与其原码相同，负数的补码是在其反码的基础上加 (1) 。<br><img src="https://www.hello-algo.com/chapter_data_structure/number_encoding.assets/1s_2s_complement.png" alt="原码、反码与补码之间的相互转换"></li></ul><p><code>然而数字却是以「补码」的形式存储在计算机中的</code></p><p>这是因为原码存在一些局限性。<br>一方面，负数的原码不能直接用于运算。例如，我们在原码下计算 (1 + (-2)) ，得到的结果是 (-3) ，这显然是不对的。<br>为了解决此问题，计算机引入了「反码」。例如，我们先将原码转换为反码，并在反码下计算 (1 + (-2)) ，并将结果从反码转化回原码，则可得到正确结果 (-1) 。<br>另一方面，数字零的原码有 (+0) 和 (-0) 两种表示方式。这意味着数字零对应着两个不同的二进制编码，而这可能会带来歧义问题。例如，在条件判断中，如果没有区分正零和负零，可能会导致错误的判断结果。如果我们想要处理正零和负零歧义，则需要引入额外的判断操作，其可能会降低计算机的运算效率。</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Lambda表达式</title>
      <link href="/posts/bbcf5ff7.html"/>
      <url>/posts/bbcf5ff7.html</url>
      
        <content type="html"><![CDATA[<h1 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在日常开发中，我们很多时候需要用到<code>Java 8</code>的<code>Lambda</code>表达式，它允许把函数作为一个方法的参数，让我们的代码更优雅，更简洁。以下为常用的表达式写法。</p><blockquote><p><strong>.collect()</strong>用来起保存作用的函数</p></blockquote><h2 id="List转Map"><a href="#List转Map" class="headerlink" title="List转Map"></a>List转Map</h2><p>Collectors.toMap可以把一个List数组转成一个Map，代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestLanbda</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;UserInfo&gt; userInfoList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        userInfoList.add(<span class="keyword">new</span> <span class="title class_">UserInfo</span>(<span class="number">1L</span>, <span class="string">&quot;采蘑菇的小姑娘&quot;</span>,<span class="number">18</span>));</span><br><span class="line">        userInfoList.add(<span class="keyword">new</span> <span class="title class_">UserInfo</span>(<span class="number">2L</span>, <span class="string">&quot;程序员男孩&quot;</span>, <span class="number">22</span>));</span><br><span class="line">        userInfoList.add(<span class="keyword">new</span> <span class="title class_">UserInfo</span>(<span class="number">2L</span>, <span class="string">&quot;捡瓶子的小姑娘&quot;</span>, <span class="number">20</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         *  List转Map</span></span><br><span class="line"><span class="comment">         *  使用Collectors.toMap的时候，如果有重复会报错，所以需要加(k1,k2) -&gt; k1</span></span><br><span class="line"><span class="comment">         *  (k1, k2) -&gt; k1 表示，如果有重复的key，则保留第一个，舍弃第二个</span></span><br><span class="line"><span class="comment">         */</span>  </span><br><span class="line">        Map&lt;Long,UserInfo&gt; userInfoMap = userInfoList.stream().collect(Collectors.toMap(UserInfo::getUserId, userInfo -&gt; userInfo, (k1, k2) -&gt; k1));</span><br><span class="line">        userInfoMap.values().forEach(a -&gt; System.out.println(a.getUserName()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用<code>toMap()</code>函数之后，返回的就是一个<code>Map</code>了，自然会需要<code>key</code>和<code>value</code></p><blockquote><p>第一个参数用来生成<code>key</code>值<br>第二个参数用来生成<code>value</code>值<br>第三个参数用在key值冲突的情况下：如果新元素产生的key在Map中已经出现过了，第三个参数就会定义解决的方法。</p></blockquote><p>在.collect(Collectors.toMap(Person::getId, v -&gt; v, (a,b) -&gt; a)):<br>第一个参数：Person:getId表示选择Person的getId作为map的key值；<br>第二个参数：v -&gt; v表示选择将原来的对象作为Map的value值<br>第三个参数：(a,b) -&gt; a中，如果a与b的key值相同，选择a作为那个key所对应的value值。</p><p>类似的，还有Collectors.toList()、Collectors.toSet()，表示把对应的流转化为List或Set。</p><p><br></p><h2 id="Filter-过滤"><a href="#Filter-过滤" class="headerlink" title="Filter()过滤"></a>Filter()过滤</h2><p>从数组集合中，过滤掉不符合条件的元素，留下符合条件的元素。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">List&lt;UserInfo&gt; userInfoList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">userInfoList.add(<span class="keyword">new</span> <span class="title class_">UserInfo</span>(<span class="number">1L</span>, <span class="string">&quot;采蘑菇的小姑娘&quot;</span>,<span class="number">18</span>));</span><br><span class="line">userInfoList.add(<span class="keyword">new</span> <span class="title class_">UserInfo</span>(<span class="number">2L</span>, <span class="string">&quot;程序员男孩&quot;</span>, <span class="number">22</span>));</span><br><span class="line">userInfoList.add(<span class="keyword">new</span> <span class="title class_">UserInfo</span>(<span class="number">2L</span>, <span class="string">&quot;捡瓶子的小姑娘&quot;</span>, <span class="number">20</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * filter过滤，留下年龄大于18的用户 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">List&lt;UserInfo&gt; userInfoResultList = userInfoList.stream().filter(user -&gt; user.getAge() &gt; <span class="number">18</span>).collect(Collectors.toList());</span><br><span class="line">userInfoResultList.forEach(a -&gt; System.out.println(a.getUserName()));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行结果</span></span><br><span class="line">程序员男孩</span><br><span class="line">捡瓶子的小姑娘</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><br></p><h2 id="forEach-循环"><a href="#forEach-循环" class="headerlink" title="forEach()循环"></a>forEach()循环</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * forEach 遍历集合List集合 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">List&lt;String&gt; userNameList = Arrays.asList(<span class="string">&quot;采蘑菇的小姑娘&quot;</span>,<span class="string">&quot;程序员男孩&quot;</span>,<span class="string">&quot;捡瓶子的小姑娘&quot;</span>);</span><br><span class="line">userNameList.forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">HashMap&lt;String, String&gt; hashMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">hashMap.put(<span class="string">&quot;姓名&quot;</span>, <span class="string">&quot;采蘑菇的小姑娘&quot;</span>);</span><br><span class="line">hashMap.put(<span class="string">&quot;职业&quot;</span>, <span class="string">&quot;程序员男孩&quot;</span>);</span><br><span class="line">hashMap.put(<span class="string">&quot;昵称&quot;</span>, <span class="string">&quot;捡瓶子的小姑娘&quot;</span>);</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  forEach 遍历集合Map</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">hashMap.forEach((k, v) -&gt; System.out.println(k + <span class="string">&quot;:\t&quot;</span> + v));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行结果</span></span><br><span class="line">采蘑菇的小姑娘</span><br><span class="line">程序员男孩</span><br><span class="line">捡瓶子的小姑娘</span><br><span class="line">姓名:采蘑菇的小姑娘</span><br><span class="line">职业:程序员男孩</span><br><span class="line">昵称:捡瓶子的小姑娘</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><br></p><h2 id="groupingBy分组"><a href="#groupingBy分组" class="headerlink" title="groupingBy分组"></a>groupingBy分组</h2><p>提到分组，相信大家都会想到<strong>SQL</strong>的<strong>group by</strong>。我们经常需要一个List做分组操作。比如，按城市分组用户。在Java8之前，是这么实现的：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">List&lt;UserInfo&gt; userInfoList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">userInfoList.add(<span class="keyword">new</span> <span class="title class_">UserInfo</span>(<span class="number">1L</span>, <span class="string">&quot;采蘑菇的小姑娘&quot;</span>,<span class="number">18</span>, <span class="string">&quot;沈阳&quot;</span>));</span><br><span class="line">userInfoList.add(<span class="keyword">new</span> <span class="title class_">UserInfo</span>(<span class="number">2L</span>, <span class="string">&quot;程序员男孩&quot;</span>, <span class="number">22</span>, <span class="string">&quot;深圳&quot;</span>));</span><br><span class="line">userInfoList.add(<span class="keyword">new</span> <span class="title class_">UserInfo</span>(<span class="number">2L</span>, <span class="string">&quot;捡瓶子的小姑娘&quot;</span>, <span class="number">20</span>, <span class="string">&quot;沈阳&quot;</span>));</span><br><span class="line"></span><br><span class="line">Map&lt;String, List&lt;UserInfo&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (UserInfo userInfo : UserInfoList) &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">city</span> <span class="operator">=</span> userInfo.getCity();</span><br><span class="line">    List&lt;UserInfo&gt; userInfos = result.get(city);</span><br><span class="line">    <span class="keyword">if</span> (userInfos == <span class="literal">null</span>) &#123;</span><br><span class="line">        userInfos = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        result.put(city, userInfos);</span><br><span class="line">    &#125;</span><br><span class="line">    userInfos.add(userInfo);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>而使用Java8的<code>groupingby</code>分组器，则很简单：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String,List&lt;UserInfo&gt;&gt; result = userInfoList.stream()</span><br><span class="line">.collect(Collectors.groupingBy(UserInfo::getCity))</span><br></pre></td></tr></table></figure></p><p><br></p><h2 id="sorted-Comparator排序"><a href="#sorted-Comparator排序" class="headerlink" title="sorted + Comparator排序"></a>sorted + Comparator排序</h2><p>在实际编写代码中，排序的需求比较多，使用<strong>sorted+Comparator</strong>排序可以简化很多<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">List&lt;UserInfo&gt; userInfoList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">userInfoList.add(<span class="keyword">new</span> <span class="title class_">UserInfo</span>(<span class="number">1L</span>, <span class="string">&quot;采蘑菇的小姑娘&quot;</span>,<span class="number">18</span>));</span><br><span class="line">userInfoList.add(<span class="keyword">new</span> <span class="title class_">UserInfo</span>(<span class="number">2L</span>, <span class="string">&quot;程序员男孩&quot;</span>, <span class="number">22</span>));</span><br><span class="line">userInfoList.add(<span class="keyword">new</span> <span class="title class_">UserInfo</span>(<span class="number">2L</span>, <span class="string">&quot;捡瓶子的小姑娘&quot;</span>, <span class="number">20</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * sorted + Comparator.comparing 排序列表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">userInfoList = userInfoList.stream().sorted(Comparator.comparing(UserInfo::getAge)).collect(Collectors.toList());</span><br><span class="line">System.out.println(<span class="string">&quot;开始升序排序&quot;</span>)</span><br><span class="line">userInfo.forEach(a -&gt; System.out.println(a.toString()));</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 如果想要降序排序，可以使用加reversed()</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">System.out.println(<span class="string">&quot;开始降序排序&quot;</span>)</span><br><span class="line">userInfoList = userInfoList.stream().sorted(Comparator.comparing(UserInfo::getAge).reversed()).collect(Collectors.toList());</span><br><span class="line">userInfo.forEach(a -&gt; System.out.println(a.toString()));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行结果</span></span><br><span class="line">开始升序排序</span><br><span class="line">userInfo&#123;userId = <span class="number">1</span>, userName = <span class="string">&#x27;采蘑菇的小姑娘&#x27;</span>, age = <span class="number">18</span>&#125;</span><br><span class="line">userInfo&#123;userId = <span class="number">3</span>, userName = <span class="string">&#x27;捡瓶子的小姑娘&#x27;</span>, age = <span class="number">20</span>&#125;</span><br><span class="line">userInfo&#123;userId = <span class="number">2</span>, userName = <span class="string">&#x27;程序员男孩&#x27;</span>, age = <span class="number">22</span>&#125;</span><br><span class="line">开始降序排序</span><br><span class="line">userInfo&#123;userId = <span class="number">2</span>, userName = <span class="string">&#x27;程序员男孩&#x27;</span>, age = <span class="number">22</span>&#125;</span><br><span class="line">userInfo&#123;userId = <span class="number">3</span>, userName = <span class="string">&#x27;捡瓶子的小姑娘&#x27;</span>, age = <span class="number">20</span>&#125;</span><br><span class="line">userInfo&#123;userId = <span class="number">1</span>, userName = <span class="string">&#x27;采蘑菇的小姑娘&#x27;</span>, age = <span class="number">18</span>&#125;</span><br></pre></td></tr></table></figure></p><p><br></p><h2 id="distinct-去重"><a href="#distinct-去重" class="headerlink" title="distinct()去重"></a>distinct()去重</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = Arrays.asList(<span class="string">&quot;A&quot;</span>,<span class="string">&quot;B&quot;</span>,<span class="string">&quot;F&quot;</span>,<span class="string">&quot;A&quot;</span>,<span class="string">&quot;C&quot;</span>);</span><br><span class="line">List&lt;String&gt; temp = list.stream().distinct().collect(Collectors.toList());</span><br><span class="line">temp.forEach(System.out::println);</span><br><span class="line"></span><br><span class="line"><span class="comment">//运行结果</span></span><br><span class="line">A</span><br><span class="line">B</span><br><span class="line">F</span><br><span class="line">C</span><br></pre></td></tr></table></figure><p><br></p><h2 id="findFirst-返回第一个"><a href="#findFirst-返回第一个" class="headerlink" title="findFirst()返回第一个"></a>findFirst()返回第一个</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = Arrays.asList(<span class="string">&quot;A&quot;</span>,<span class="string">&quot;B&quot;</span>,<span class="string">&quot;F&quot;</span>,<span class="string">&quot;A&quot;</span>,<span class="string">&quot;C&quot;</span>);</span><br><span class="line">list.stream().findFirst().ifPresent(System.out::println);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行结果</span></span><br><span class="line">A</span><br></pre></td></tr></table></figure><p><br></p><h2 id="anyMatch-和allMatch-匹配"><a href="#anyMatch-和allMatch-匹配" class="headerlink" title="anyMatch()和allMatch()匹配"></a>anyMatch()和allMatch()匹配</h2><p><strong>anyMatch()检查流是否包含至少一个满足要求</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;String&gt; stream = Stream.of(<span class="string">&quot;A&quot;</span>,<span class="string">&quot;B&quot;</span>,<span class="string">&quot;C&quot;</span>,<span class="string">&quot;D&quot;</span>);</span><br><span class="line"><span class="type">boolean</span> <span class="variable">match</span> <span class="operator">=</span> stream.anyMatch(s -&gt; s.contains(<span class="string">&quot;C&quot;</span>));</span><br><span class="line">System.out.println(match);</span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line"><span class="literal">true</span></span><br></pre></td></tr></table></figure><br><strong>allMatch()检查流是否所有都满足</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;String&gt; stream = Stream.of(<span class="string">&quot;A&quot;</span>,<span class="string">&quot;B&quot;</span>,<span class="string">&quot;C&quot;</span>,<span class="string">&quot;D&quot;</span>);</span><br><span class="line"><span class="type">boolean</span> <span class="variable">match</span> <span class="operator">=</span> stream.anyMatch(s -&gt; s.length() == <span class="number">1</span>);</span><br><span class="line">System.out.println(match);</span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line"><span class="literal">true</span></span><br></pre></td></tr></table></figure></p><p><br></p><h2 id="常用函数式接口"><a href="#常用函数式接口" class="headerlink" title="常用函数式接口"></a>常用函数式接口</h2><p>函数式接口(Functional Interface)就是<strong>一个有且仅有一个抽象方法，但是可以有多个非抽象方法的接口</strong><br>函数式接口可以被隐式转换为<code>Lambda</code>表达式<br><code>Lambda</code>表达式和方法引用(实际上也可认为是<code>Lambda</code>表达式)上</p><h3 id="常见的函数式接口"><a href="#常见的函数式接口" class="headerlink" title="常见的函数式接口"></a>常见的函数式接口</h3><ul><li><code>Function&lt;T, R&gt;</code>(转换型):接收一个输入参数，返回一个结果</li><li><code>Comsumer&lt;T&gt;</code>(消费型):接收一个输入参数，并且无返回操作</li><li><code>Predicate&lt;T&gt;</code>(判断型):接收一个输入参数，并且返回布尔值结果</li><li><code>Supplier&lt;T&gt;</code>(供给型):无参数，无返回结果</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>装饰者模式</title>
      <link href="/posts/a708a60d.html"/>
      <url>/posts/a708a60d.html</url>
      
        <content type="html"><![CDATA[<h1 id="装饰者模式"><a href="#装饰者模式" class="headerlink" title="装饰者模式"></a>装饰者模式</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>装饰者模式也称为包装模式(Wrapper Pattern)，属于结构型设计模式。该模式对客户端透明的方式来动态的扩展对象，(对扩展开发，对修改关闭)同时该模式也是继承关系的替代方法之一。<br>总之该模式就是动态的给对象添加一些额外的职责，类似于我们点咖啡加糖加奶<br><img src="https://tse2-mm.cn.bing.net/th/id/OIP-C.bDK0Tg5zzewZP2CjFN-wswHaEX?pid=ImgDet&amp;rs=1" alt="咖啡"></p><p><br></p><p>装饰者模式的结构分为以下几类</p><ul><li>抽象组件(<code>Component</code>)：定义装饰方法的规范</li><li>被装饰者(<code>ConcreteComponent</code>)：<code>Component</code>的具体实现，也就是我们要装饰的具体对象</li><li>装饰者组件(<code>Decorator</code>)：持有组件(``)对象的实例引用，该类的职责就是为了装饰具体组件对象，定义的规范</li><li>具有装饰(<code>ConcreteDecorator</code>)：负责给构件对象装饰附加的功能<br><img src="https://i.328888.xyz/2023/04/23/iSccOP.png" alt="结构类图"><blockquote><ol><li>装饰者和被装置者有相同的超类(Component)</li><li>你可以用一个或多个具体装饰(ConcreteDecorator)包装一个对象</li><li>装饰者可以在所委托被装饰者的行为之前与/ 或之后，加上自己的行为，以达到特点的目的(类似代理模式)</li><li>对象可以在任何时候被装饰，所以可以在运行时动态地、不限量的用你喜欢的装饰者来装饰对象</li></ol></blockquote></li></ul><p><br></p><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><h3 id="inputStream"><a href="#inputStream" class="headerlink" title="inputStream"></a>inputStream</h3><p><img src="https://i.328888.xyz/2023/04/23/iScp1t.jpeg" alt="InputStream"></p><ul><li>抽象组件(InputStream) ：装饰者模式中的超类，它只有一个抽象方法read()，子类都需要对该方法进行处理</li><li>被装饰者(FileInputStream , ByteArrayInputStream , StringBufferInputStream) ：拥有通用实现read()基本方法</li><li>装饰者组件(FilterInputStream) ：定义具体装饰者的行为规范，可以做统一基础处理。</li><li>具体装饰(BufferedInputStream , DataInputStream , Base64InputStream) ：具体的装饰类，拥有对流的读操作做完成具体拓展能力。</li></ul><blockquote><p>装饰者模式让我们可以有不同的被装饰者，例如FileInputStream，并且如果想使用缓冲功能那么只需写一下代码 ：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;path&quot;</span>)));</span><br></pre></td></tr></table></figure><blockquote><p>也可以对上面代码再进行加工，简单的加密处理 ：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Base64InputStream</span>(<span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;&quot;</span>))),<span class="number">0</span>)</span><br></pre></td></tr></table></figure><blockquote><p>哪怕你突然改需求了，读取的对象不是文件，而是文本或字符，那么可以轻松的将代码改为 ：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Base64InputStream</span>(<span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(<span class="keyword">new</span> <span class="title class_">StringBufferInputStream</span>(<span class="string">&quot;str&quot;</span>)),<span class="number">0</span>)</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>装饰者模式能够很好的增强对象的拓展功能，如果抽象组件定义的类型是人（抽象方法是攻击力）</p><p>那么被装饰者可以是“法师”，“战士”，“射手”，“肉坦”，装饰者模式可以让我们无需关注这些被装饰者（ConcreteComponent）</p><p>我们可以实现不同的装饰功能（ConcreteDecorator），例如匕首（+5），长剑（+10），法杖（+1）</p><p><br></p><blockquote><p>OO原则：动态地将责任附加到对象上。想要扩展功能， 装饰者提供有别于继承的另一种选择。</p></blockquote><ol><li>继承属于扩展形式之一，但不见得是达到弹性设计的最佳方案。</li><li>在我们的设计中，应该允许行为可以被扩展，而不须修改现有的代码。</li><li>组合和委托可用于在运行时动态地加上新的行为。</li><li>除了继承，装饰者模式也可以让我们扩展行为。</li><li>装饰者模式意味着一群装饰者类， 这些类用来包装具体组件。</li><li>装饰者类反映出被装饰的组件类型（实际上，他们具有相同的类型，都经过接口或继承实现）。</li><li>装饰者可以在被装饰者的行为前面与/或后面加上自己的行为，甚至将被装饰者的行为整个取代掉，而达到特定的目的。</li><li>你可以有无数个装饰者包装一个组件。</li><li>装饰者一般对组建的客户是透明的，除非客户程序依赖于组件的具体类型。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>单例模式</title>
      <link href="/posts/364ea8cc.html"/>
      <url>/posts/364ea8cc.html</url>
      
        <content type="html"><![CDATA[<h1 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><ul><li>单例模式属于<strong>创建型模式</strong>，一个单例类在任何情况下都只存在一个实例，构造方法必须是私有的、由自己创建一个静态变量存储实例，对外提供一个静态公有方法获取实例。</li><li>优点是内存中只有一个实例，减少了开销，尤其是频繁的创建和销毁实例的情况下并且可以避免对资源的多重占用。缺点是没有抽象层，难以扩展，与单一职责原则冲突。</li></ul><p><img src="https://www.runoob.com/wp-content/uploads/2014/08/62576915-36E0-4B67-B078-704699CA980A.jpg" alt="单例模式"></p><h2 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h2><p><strong>饿汉式单例模式</strong>，顾名思义，<strong>类一加载就创建对象</strong>，这种方式比较常用。<br><strong>缺点</strong></p><ul><li>容易产生垃圾对象，浪费内存空间；</li><li>单例会在加载类后一开始就被初始化，即使客户端没有调用getInstance()方法。饿汉式的创建方式在一些场景中将无法使用：例如Singleton实例的创建是依赖参数或者配置文件的，在getInstance()之前必须调用某个方法设置参数给它，那样这种单例写法就无法使用。</li></ul><p><strong>优点</strong><br><strong>线程安全，没有加锁，执行效率较高</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="comment">//1.私有化构造方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="comment">//2.定义一个静态变量指向自己类型</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    <span class="comment">//3.对外提供一个公共的方法获取实例</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><h2 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式"></a>懒汉式</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>)&#123;</span><br><span class="line">            instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>缺点</strong>：当有多个线程并行调用getInstance()的时候，就会创建多个实例。也就是说在多线程下不能正常工作。</p><p><strong>解决方案</strong>：<br>为了解决上面的问题，最简单的方法是将整个<code>getInstance()</code>方法设为同步(<code>synchronized</code>)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singeleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">        instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>此方法虽然做到了线程安全，并且解决了多实例的问题，但是它并不高效。因为在任何时候只能有一个线程调用<code>getInstance()</code>方法。<br>但是同步操作只在第一次调用时才被需要，即第一次创建单例实例对象时。</p><blockquote><p>这时候我们就需要<strong>双重检验锁</strong></p></blockquote><p><br></p><h2 id="双重检验锁-DCL-——-double-checked-locking"><a href="#双重检验锁-DCL-——-double-checked-locking" class="headerlink" title="双重检验锁(DCL —— double-checked locking)"></a>双重检验锁(DCL —— double-checked locking)</h2><p><strong>双重检验锁模式(double checked locking pattern)</strong>，是一种使用同步块加锁的方法。程序员称其为双重检查锁，因为会有两次检查<code>instance == null</code>，一次是在同步块外，一次是在同步块内。<br>为什么在同步块内还要再检验一次？因为可能会有多个线程一起进入同步块外的if，如果在同步块内不进行二次检验的话就会生成多个实例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="comment">// 声明成volatile</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这里的双重检验是指两次非空判断，锁是指<code>synchronized</code>加锁</p><ul><li><strong>第一重判断</strong>，如果实例已经存在，那么就不用再进行同步操作，而是直接返回这个实例，如果没有创建，才会进入同步块，同步块的目的与之前相同，目的是为了防止有多个线程同时调用时，生成多个实例，有了同步块，每次只能有一个线程调用访问同步块内容，当第一个抢到锁的调用获取了实例之后，这个实例就会被创建，之后的所有调用都不会进入同步块，直接在第一重判断就返回了单例；</li><li><strong>第二重空判断</strong>，当多个线程一起到达锁位置时，进行锁竞争，其中一个线程获取锁，如果是第一次进入则为null，会进行单例对象的创建，完成后释放锁，其他线程获取锁后就会被空判断拦截，直接返回已创建的单例对象。</li></ul><p><code>instance = new Singleton()</code>并非是一个原子操作，事实上在JVM中这句话大概做了一下三件事：</p><ol><li>给<code>instance</code>分配内存</li><li>调用<code>Singleton</code>的构造函数来初始化成员变量</li><li>将<code>instance</code>对象指向分配的内存空间(执行完这步<code>instance</code>就为非null了)</li></ol><p>但在JVM 的即时编译器中存在指令重排序的优化。也就是说上面的第二步和第三步的顺序是不能保证的，最终的执行顺序可能是1-2-3也可能是1-3-2.如果是后者，则在3执行完毕，2未执行之前，被线程二抢占了，这时<code>instance</code>已经是非null了(但是没有初始化)，所以线程二会直接返回<code>instance</code>，然后使用，这时就会出错</p><blockquote><p>将<code>instance</code>变量声明成<code>volatile</code>就可以避免了</p></blockquote><p><br></p><h2 id="Why-volatile"><a href="#Why-volatile" class="headerlink" title="Why volatile ?"></a>Why volatile ?</h2><p>有些人认为使用<code>volatile</code>的原因是可见性，也就是可以保证线程在本地不会存有<code>instance</code>的副本，每次都是去主内存中读取。但其实是不对的。使用<code>volatile</code>的主要原因是其另外一个特性：<strong>禁止指令重排序优化</strong>。<br>也就是说，在<code>volatile</code>变量的赋值操作后面会有一个<strong>内存屏障</strong>(生成的汇编代码上)，读操作不会被重排序到内存屏障之前。比如上面的例子，取操作必须在执行完1-2-3之后或者1-3-2之后，不存在执行到1-3然后取到值的情况。<br>从<strong>先行发生原则</strong>的角度理解的话，就是对于一个volatile变量的写操作都先行发生于后面对这个变量的读操作。<br>但是Java5之前的版本使用volatile的双检锁还是有问题的。其原因是Java5以前的JMM(Java内存模型)是存在缺陷的，即使将变量声明成volatile也不能完全避免重排序，主要是volatile变量前后的代码仍然存在重排序问题。这个volatile屏蔽重排序的问题在Java5中才得以修复。</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>动态规划</title>
      <link href="/posts/a80d0031.html"/>
      <url>/posts/a80d0031.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>排序算法</title>
      <link href="/posts/735e5788.html"/>
      <url>/posts/735e5788.html</url>
      
        <content type="html"><![CDATA[<h1 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h1><h2 id="排序算法说明"><a href="#排序算法说明" class="headerlink" title="排序算法说明"></a>排序算法说明</h2><h3 id="排序的定义"><a href="#排序的定义" class="headerlink" title="排序的定义"></a>排序的定义</h3><p>对一序列对象根据某个关键字进行排序</p><h3 id="术语说明"><a href="#术语说明" class="headerlink" title="术语说明"></a>术语说明</h3><ul><li>稳定：如果a原本在b前面，而a=b，排序之后a仍然在b的前面</li><li>不稳定：如果a原本在b前面，而a=b，排序之后a可能会出现在b的后面</li><li>内排序：所有排序操作都在内存中完成；</li><li>外排序：由于数据太大，因此把数据放在磁盘中，而排序通过磁盘和内存的数据传输才能进行；</li><li>时间复杂度：一个算法执行所耗费的时间</li><li>空间复杂度：运行完一个程序所需内存的大小</li></ul><h3 id="算法总结"><a href="#算法总结" class="headerlink" title="算法总结"></a>算法总结</h3><p><img src="https://www.runoob.com/wp-content/uploads/2019/03/sort.png" alt="排序算法"><br><strong>总结名词解释</strong></p><ul><li>n:数据规模</li><li>k:“桶”的个数</li><li>In-place:占用常数内存，不占用额外内存</li><li>Out-place:占用额外内存</li></ul><h3 id="比较与非比较的区别"><a href="#比较与非比较的区别" class="headerlink" title="比较与非比较的区别"></a>比较与非比较的区别</h3><p>常见的<strong>快速排序、归并排序、堆排序、冒泡排序</strong>等属于<strong>比较排序</strong>。<code>在排序的最终结果里，元素之间的次序依赖于它们之间的比较。每个数都必须和其他数进行比较，才能确定自己的位置。</code><br>在冒泡排序之类的排序中，问题规模为n，又因为需要比较n次，所以平均时间复杂度为O(n²)。在归并排序、快速排序之类的排序中，问题规模通过分治法消减为logN次，所以时间复杂度平均O(nlogn)。<br>比较排序的优势是，适用于各种规模的数据，也不在乎数据的分布，都能进行排序。可以说，<code>比较排序适用于一切需要排序的情况。</code></p><p><strong>计数排序、基数排序、桶排序</strong>则属于<strong>非比较排序</strong>。<code>非比较排序是通过确定每个元素之前，应该有多少个元素来排序。针对数组arr，计算arr[i]之前有多少个元素，则唯一确定了arr[i]在排序后数组中的位置。</code><br>非比较排序只要确定每个元素之前的已有的元素个数即可，所有一次遍历即可解决。算法时间复杂度O(n)。<br><strong>非比较排序时间复杂度底，但由于非比较排序需要占用空间来确定唯一位置。所以对数据规模和数据分布有一定的要求。</strong></p><h2 id="冒泡排序-Bubble-Sort"><a href="#冒泡排序-Bubble-Sort" class="headerlink" title="冒泡排序(Bubble Sort)"></a>冒泡排序(Bubble Sort)</h2><p>冒泡排序是一种简单的排序算法。它重复地走访要排序的数列，一次比较两个元素，如果它们错误就把它们交换过来。走访数列的工作是重复的进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。</p><h3 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h3><ul><li>比较相邻的元素，如果第一个比第二个大，就交换它们两个；</li><li>对每一对相邻元素作相同的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数；</li><li>针对所有的元素重复以上的步骤，除了最后一个；</li><li>重复步骤1~3，直到排序完成</li></ul><h3 id="动画演示"><a href="#动画演示" class="headerlink" title="动画演示"></a>动画演示</h3><p><img src="https://www.runoob.com/wp-content/uploads/2019/03/bubbleSort.gif" alt="冒泡排序"></p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>可以对冒泡排序设置一个标记flag，从而优化冒泡排序时间复杂度</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] bubbleSort(<span class="type">int</span>[] array) &#123;</span><br><span class="line">    <span class="keyword">if</span> (array.length == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> array;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt; array.length; i++&gt;) &#123;</span><br><span class="line">        <span class="comment">// 设定一个标记，若为true，则表示此次循环没有进行交换，也就是待排序列已经有序，排序已经完成。</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;j &lt; array.length - i; j++&gt;) &#123;</span><br><span class="line">            <span class="keyword">if</span> (array[j + <span class="number">1</span>] &lt; array[j]) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> array [j];</span><br><span class="line">                array[j] = array[j + <span class="number">1</span>];</span><br><span class="line">                array[j + <span class="number">1</span>] = temp;</span><br><span class="line"></span><br><span class="line">                flag = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h3><p>最佳情况：T(n) = O(n)<br>最差情况：T(n) = O(n^2)<br>平均情况：T(n) = O(n^2)</p><p>空间复杂度：O(1)</p><p><br></p><h2 id="选择排序-Selection-Sort"><a href="#选择排序-Selection-Sort" class="headerlink" title="选择排序(Selection Sort)"></a>选择排序(Selection Sort)</h2><p>表现最稳定的排序算法之一，无论什么数据进去都是O(n^2)的时间复杂度，所以用到它的时候，数据规模越小越好。唯一的好处可能就是不占用额外的内存空间了吧。理论上讲，选择排序可能也是平时排序一般人想到的最多的排序方法了吧<br>选择排序(Selection Sort)是一种简单直观的排序算法。它的工作原理：首先在末排序序列中找到最小(大)元素，存放到排序序列的起始位置，然后再从剩余未排序元素中继续寻找最小(大)元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。</p><h3 id="算法描述-1"><a href="#算法描述-1" class="headerlink" title="算法描述"></a>算法描述</h3><p>n个记录的直接选择排序可经过n-1趟直接选择排序得到有序结果。具体算法描述如下：</p><ul><li>初始状态：无序区为R[1..n]，有序区为空</li><li>第i趟排序排序(i=1,2,3…n-1)开始时，当前有序区和无序区分别为R[1..i-1]和R(i..n)。该趟排序从当前无序区中选出关键字最小的记录R[k]，将它与无序区的第一个记录R交换，使R[1..i]和R[i+1..n]分别变成记录个数增加1个的新有序区和记录个数减少1个的新无序区。</li><li>n-1趟结束，数组有序化了。</li></ul><h3 id="动画演示-1"><a href="#动画演示-1" class="headerlink" title="动画演示"></a>动画演示</h3><p><img src="https://www.runoob.com/wp-content/uploads/2019/03/selectionSort.gif" alt="选择排序"></p><h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] selectionSort(<span class="type">int</span>[] array) &#123;</span><br><span class="line">    <span class="keyword">if</span> (array.length == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> array;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 总共要经过N-1轮比较</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; array.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">minIndex</span> <span class="operator">=</span> i;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 每轮需要比较的次数为N-i</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; array.length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (array[j] &lt; array[minIndex]) &#123;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 记录目前能找到的最小值元素的下标</span></span><br><span class="line">                minIndex = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将找到的最小值和i位置所在的值进行交换</span></span><br><span class="line">        <span class="keyword">if</span> (i != minIndex) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> array[i];</span><br><span class="line">            array[i] = array[minIndex];</span><br><span class="line">            array[minIndex] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="算法分析-1"><a href="#算法分析-1" class="headerlink" title="算法分析"></a>算法分析</h3><p>最佳情况：T(n) = O(n^2)<br>最差情况：T(n) = O(n^2)<br>平均情况：T(n) = O(n^2)</p><p>空间复杂度：O(1)</p><p><br></p><h2 id="插入排序-Insertion-Sort"><a href="#插入排序-Insertion-Sort" class="headerlink" title="插入排序(Insertion Sort)"></a>插入排序(Insertion Sort)</h2><p>插入排序(Insertion Sort)的算法描述是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。插入排序在实现上，通常采用in-place排序（即只需用到O(1)的额外空间的排序），因而在从后向前扫描过程中，需要反复把已经排序元素逐步向后挪位，为最新元素提供插入空间。</p><h3 id="算法描述-2"><a href="#算法描述-2" class="headerlink" title="算法描述"></a>算法描述</h3><p>一般来说，插入排序都采用in-place在数组上实现。具体算法描述如下：</p><ul><li>从第一个元素开始，该元素可以认为已经被排序；</li><li>取出下一个元素，在已经排序的元素序列中从后向前扫描；</li><li>如果该元素(已排序)大于新元素，将该元素移到下一位置；</li><li>重复步骤3，直到找到已排序的元素小于或者等于新元素的位置；</li><li>将新元素插入到该位置后；</li><li>重复步骤2~5</li></ul><h3 id="动画演示-2"><a href="#动画演示-2" class="headerlink" title="动画演示"></a>动画演示</h3><p><img src="https://www.runoob.com/wp-content/uploads/2019/03/insertionSort.gif" alt="插入排序"></p><h3 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] insertionSort(<span class="type">int</span>[] array) &#123;</span><br><span class="line">    <span class="keyword">if</span> (array.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> array;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 从小标为1的元素开始选择合适的位置插入，因为下标为0的只有一个元素，默认是有序的</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt; array.length; i++) &#123;</span><br><span class="line">        <span class="comment">// 记录要插入的数据</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> array[i];</span><br><span class="line">        <span class="comment">// 从已经排序的序列最右边开始比较，找到比其小的数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i;</span><br><span class="line">        <span class="keyword">while</span>(j &gt; <span class="number">0</span> &amp;&amp; temp &lt; array[j - <span class="number">1</span>]) &#123;</span><br><span class="line">            array[j] = array[j - <span class="number">1</span>];</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 存在比其小的数，插入</span></span><br><span class="line">        <span class="keyword">if</span> (j != i) &#123;</span><br><span class="line">            array[j] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="算法分析-2"><a href="#算法分析-2" class="headerlink" title="算法分析"></a>算法分析</h3><p>最佳情况：T(n) = O(n)<br>最坏情况：T(n) = O(n^2)<br>平均情况：T(n) = O(n^2)</p><p>空间复杂度：O(1)</p><p><br></p><h2 id="希尔排序-Shell-Sort"><a href="#希尔排序-Shell-Sort" class="headerlink" title="希尔排序(Shell Sort)"></a>希尔排序(Shell Sort)</h2><p>希尔排序是希尔(Donald Shell)于1959年提出的一种排序算法。希尔排序也是一种插入排序，它是简单插入排序经过改进之后的一个更高效的版本，也称为缩小增量排序，同时该算法是冲破O(n^2)的第一批算法之一。它与插入排序的不同之处在于，它会优先比较距离较远的元素。希尔排序又叫缩小增量排序。</p><blockquote><p>希尔排序是把记录按下表的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰被分成一组，算法便终止</p></blockquote><h3 id="算法描述-3"><a href="#算法描述-3" class="headerlink" title="算法描述"></a>算法描述</h3><p>我们来看下希尔排序的基本步骤，在此我们选择增量gap = length/2，缩小增量继续以gap = gap/2的方式，这种增量选择我们可以用一个序列来表示，{n/2,(n/2)/2…..1}，称为增量序列。希尔排序的增量序列是比较常用的，也是希尔建议的增量，称为希尔增量，但其实中国增量序列不是最优的。此处我们做示例使用希尔增量。<br>先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，具体算法描述：</p><ul><li>选择一个增量序列t1，t2，…..，tk，其中ti&gt;tj,tk = 1;</li><li>按增量序列个数k，对序列进行k趟排序；</li><li>每趟排序，根据对应的增量ti，将待排序序列分割成若干长度为m的子序列，分别对各个子表进行直接插入排序。仅增量因子为1时，整个序列作为一个表来处理，表长度即为整个序列的长度。</li></ul><h3 id="动画演示-3"><a href="#动画演示-3" class="headerlink" title="动画演示"></a>动画演示</h3><p><img src="https://www.runoob.com/wp-content/uploads/2019/03/Sorting_shellsort_anim.gif" alt="希尔排序"></p><h3 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] shellSort(<span class="type">int</span>[] array) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> array.length;</span><br><span class="line">    <span class="type">int</span> temp, gap = len / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span>(gap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> gap; i &lt; len; i++) &#123;</span><br><span class="line">            temp = array[i];</span><br><span class="line">            <span class="type">int</span> <span class="variable">preIndex</span> <span class="operator">=</span> i - gap;</span><br><span class="line">            <span class="keyword">while</span> (preIndex &gt;= <span class="number">0</span> &amp;&amp; array[preIndex] &gt; temp) &#123;</span><br><span class="line">                array[preIndex + gap] = array[preIndex];</span><br><span class="line">                preIndex -= gap;</span><br><span class="line">            &#125;</span><br><span class="line">            array[preIndex + gap] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        gap /= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="算法分析-3"><a href="#算法分析-3" class="headerlink" title="算法分析"></a>算法分析</h3><p>最佳情况：T(n) = O(nlog2n)<br>最坏情况：T(n) = O(nlog2n)<br>平均情况：T(n) = O(nlog2n)</p><p>空间复杂度：O(1)</p><p><br></p><h2 id="归并排序-Merge-Sort"><a href="#归并排序-Merge-Sort" class="headerlink" title="归并排序(Merge Sort)"></a>归并排序(Merge Sort)</h2><p>和选择排序一样，归并排序的性能不受输入数据的影响，但表现比选择排序好的多，因为始终都是O(nlogn)的时间复杂度，代价是需要额外的空间。<br>归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治法(Divide and Conquer)的一个非常典型的应用。归并排序是一种稳定的排序方法。将已有序的子序列合并，就能得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为2路归并。</p><h3 id="算法描述-4"><a href="#算法描述-4" class="headerlink" title="算法描述"></a>算法描述</h3><ul><li>把长度为n的输入序列分成两个长度为n/2的子序列；</li><li>对这两个子序列分别采用归并排序；</li><li>将两个排序好的子序列合并成一个最终的排序序列</li></ul><h3 id="动画演示-4"><a href="#动画演示-4" class="headerlink" title="动画演示"></a>动画演示</h3><p><img src="https://www.runoob.com/wp-content/uploads/2019/03/mergeSort.gif" alt="归并排序"></p><h3 id="代码实现-4"><a href="#代码实现-4" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] mergeSort(<span class="type">int</span>[] array) &#123;</span><br><span class="line">    <span class="keyword">if</span> (array.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> array;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> array.length / <span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span>[] left = Arrays.copyOfRange(array,<span class="number">0</span>,mid);</span><br><span class="line">    <span class="type">int</span>[] right = Arrays.copyOfRange(array,mid,array.length);</span><br><span class="line">    <span class="keyword">return</span> merge(mergeSort(left),mergeSort(right));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] merge(<span class="type">int</span>[] left,<span class="type">int</span>[] right) &#123;</span><br><span class="line">    <span class="type">int</span>[] result = <span class="keyword">new</span> <span class="title class_">int</span>[left.length + right.length];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>,i = <span class="number">0</span>,j = <span class="number">0</span>;index &lt; result.length; index++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= left.length) &#123;</span><br><span class="line">            result[index] = right[j];</span><br><span class="line">            j++;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (j &gt;= right.length) &#123;</span><br><span class="line">            result[index] = left[i];</span><br><span class="line">            i++;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (left[i] &gt; right[j]) &#123;</span><br><span class="line">            result[index] = right[j];</span><br><span class="line">            j++;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            result[index] = left[i];</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="算法分析-4"><a href="#算法分析-4" class="headerlink" title="算法分析"></a>算法分析</h3><p>最佳情况：T(n) = O(n)<br>最差情况：T(n) = O(nlogn)<br>平均情况：T(n) = O(nlogn)</p><p>空间复杂度：O(n)</p><p><br></p><h2 id="快速排序-Quick-Sort"><a href="#快速排序-Quick-Sort" class="headerlink" title="快速排序(Quick Sort)"></a>快速排序(Quick Sort)</h2><p>快速排序的基本思想：通过一趟排序将待排记录分隔成独立的两个部分，其中一部分记录的关键字均比另外一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。</p><h3 id="算法描述-5"><a href="#算法描述-5" class="headerlink" title="算法描述"></a>算法描述</h3><p>快速排序使用分治法来把一个串(list)分成两个字串(sub-lists)。具体算法描述如下：</p><ul><li>从数列中挑出一个元素，称为“基准”(pivot);</li><li>重新排列数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面(相同的数可以到任一边)。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区(partition)操作；</li><li>递归地(recursive)把小于基准值元素的子数列和大于基准值元素的子数列排序。</li></ul><h3 id="动画演示-5"><a href="#动画演示-5" class="headerlink" title="动画演示"></a>动画演示</h3><p><img src="https://www.runoob.com/wp-content/uploads/2019/03/quickSort.gif" alt="快速排序"></p><h3 id="代码实现-5"><a href="#代码实现-5" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] quickSort(<span class="type">int</span>[] array,<span class="type">int</span> left,<span class="type">int</span> right) &#123;</span><br><span class="line">    <span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="comment">// 哨兵划分</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">pivot</span> <span class="operator">=</span> partition(array, left, right);</span><br><span class="line">        <span class="comment">// 递归左子数组，右子数组</span></span><br><span class="line">        quickSort(array, left, pivot - <span class="number">1</span>);</span><br><span class="line">        quickSort(array, pivot + <span class="number">1</span>, right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">partition</span><span class="params">(<span class="type">int</span>[] array, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">    <span class="comment">// 以array[left]作为基准数</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> left, j = right;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j &amp;&amp; array[j] &gt;= array[left])&#123;</span><br><span class="line">            <span class="comment">// 从右向左找首个小于基准数的元素</span></span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j &amp;&amp; array[i] &lt;= array[left])&#123;</span><br><span class="line">            <span class="comment">// 从左向右找首个大于基准数的元素</span></span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 交换这两个元素</span></span><br><span class="line">        swap(array,i,j);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将基准数交换至两子数组的分界线</span></span><br><span class="line">    swap(array,i,left);</span><br><span class="line">    <span class="comment">// 返回基准数的索引</span></span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] array,<span class="type">int</span> i,<span class="type">int</span> j)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> array[i];</span><br><span class="line">    array[i] = array[j];</span><br><span class="line">    array[j] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="算法分析-5"><a href="#算法分析-5" class="headerlink" title="算法分析"></a>算法分析</h3><p>最佳情况：T(n) = O(nlogn)<br>最差情况：T(n) = O(n^2)<br>平均情况：T(n) = O(nlogn)</p><p>空间复杂度：O(logn)</p><p><br></p><h2 id="堆排序-Heap-Sort"><a href="#堆排序-Heap-Sort" class="headerlink" title="堆排序(Heap Sort)"></a>堆排序(Heap Sort)</h2><p>堆排序(Heap Sort)是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结果，并同时满足堆积的性质：即子结点的键值或索引总是小于(或大于)它的父节点。</p><h3 id="算法描述-6"><a href="#算法描述-6" class="headerlink" title="算法描述"></a>算法描述</h3><ul><li>将初始待排序关键字序列(R1,R2,…,Rn)构建成大顶堆，此堆为初始的无序区；</li><li>将堆顶元素R[1]与最后一个元素R[n]交换，此时得到新的无序区(R1,R2,…,Rn-1)和新的有序区(Rn)，且满足R[1，2…n-1] &lt;= R[n];</li><li>由于交换后新的堆顶R[1]可能违反堆的性质，因此需要对当前无序区(R1,R2,…,Rn-1)调整为新堆，然后再次将R[1]与无序区最后一个元素交换，得到新的无序区(R1,R2,..Rn-2)和新的有序区(Rn-1,Rn)。不断重复此过程直到有序区的元素个数为n-1，则整个排序过程完成。</li></ul><h3 id="动画演示-6"><a href="#动画演示-6" class="headerlink" title="动画演示"></a>动画演示</h3><p><img src="https://www.runoob.com/wp-content/uploads/2019/03/heapSort.gif" alt="堆排序1"><br><img src="https://www.runoob.com/wp-content/uploads/2019/03/Sorting_heapsort_anim.gif" alt="堆排序2"></p><h3 id="代码实现-6"><a href="#代码实现-6" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> len;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] heapSort(<span class="type">int</span>[] array) &#123;</span><br><span class="line">    len = array.length;</span><br><span class="line">    <span class="keyword">if</span> (len &lt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> array;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 构建一个最大堆</span></span><br><span class="line">    bulidMaxHeap(array);</span><br><span class="line">    <span class="comment">// 循环将堆首位(最大值)与末位交换，然后重新调整最大堆</span></span><br><span class="line">    <span class="keyword">while</span> (len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        swap(array, <span class="number">0</span>, len - <span class="number">1</span>);</span><br><span class="line">        len--;</span><br><span class="line">        adjustHeap(array, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 建立最大堆</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">buildMaxHeap</span><span class="params">(<span class="type">int</span>[] array)</span> &#123;</span><br><span class="line">    <span class="comment">// 从最后一个非叶子节点开始向上构造最大堆</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> (len / <span class="number">2</span> - <span class="number">1</span>); i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        adjustHeap(array, i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调整使之成为最大堆</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">adjustHeap</span><span class="params">(<span class="type">int</span>[] array, <span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">maxIndex</span> <span class="operator">=</span> i;</span><br><span class="line">    <span class="comment">//如果有左子树，且左子树大于父节点，则将最大指针指向左子树</span></span><br><span class="line">    <span class="keyword">if</span> (i * <span class="number">2</span> &lt; len &amp;&amp; array[i * <span class="number">2</span>] &gt; array[maxIndex])</span><br><span class="line">        maxIndex = i * <span class="number">2</span>;</span><br><span class="line">    <span class="comment">//如果有右子树，且右子树大于父节点，则将最大指针指向右子树</span></span><br><span class="line">    <span class="keyword">if</span> (i * <span class="number">2</span> + <span class="number">1</span> &lt; len &amp;&amp; array[i * <span class="number">2</span> + <span class="number">1</span>] &gt; array[maxIndex])</span><br><span class="line">        maxIndex = i * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//如果父节点不是最大值，则将父节点与最大值交换，并且递归调整与父节点交换的位置。</span></span><br><span class="line">    <span class="keyword">if</span> (maxIndex != i) &#123;</span><br><span class="line">        swap(array, maxIndex, i);</span><br><span class="line">        adjustHeap(array, maxIndex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] array,<span class="type">int</span> i,<span class="type">int</span> j)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> array[i];</span><br><span class="line">    array[i] = array[j];</span><br><span class="line">    array[j] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="算法分析-6"><a href="#算法分析-6" class="headerlink" title="算法分析"></a>算法分析</h3><p>最佳情况：T(n) = O(nlogn)<br>最差情况：T(n) = O(nlogn)<br>平均情况：T(n) = O(nlogn)</p><p>空间复杂度：O(1)</p><p><br></p><h2 id="计数排序-Counting-Sort"><a href="#计数排序-Counting-Sort" class="headerlink" title="计数排序(Counting Sort)"></a>计数排序(Counting Sort)</h2><p>计数排序的核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。<br>计数排序(Counting Sort)是一种稳定的排序算法。计数排序使用一个额外的数组C，其中第i个元素是待排序数组A中值等于i的元素的个数。然后根据数组C来将A中的元素排到正确的位置。它只能对整数进行排序。</p><blockquote><p>计数排序的特征<br>当输入的元素是 n 个 0 到 k 之间的整数时，它的运行时间是 Θ(n + k)。计数排序不是比较排序，排序的速度快于任何比较排序算法。<br>由于用来计数的数组C的长度取决于待排序数组中数据的范围（等于待排序数组的最大值与最小值的差加上1），这使得计数排序对于数据范围很大的数组，需要大量时间和内存。例如：计数排序是用来排序0到100之间的数字的最好的算法，但是它不适合按字母顺序排序人名。但是，计数排序可以用在基数排序中的算法来排序数据范围很大的数组。<br>通俗地理解，例如有 10 个年龄不同的人，统计出有 8 个人的年龄比 A 小，那 A 的年龄就排在第 9 位,用这个方法可以得到其他每个人的位置,也就排好了序。当然，年龄有重复时需要特殊处理（保证稳定性），这就是为什么最后要反向填充目标数组，以及将每个数字的统计减去 1 的原因。</p></blockquote><h3 id="算法描述-7"><a href="#算法描述-7" class="headerlink" title="算法描述"></a>算法描述</h3><ul><li>找出待排序的数组中最大和最小的元素；</li><li>统计数组中每个值为i的元素出现的次数，存入数组C的第i项；</li><li>对所有的计数累加(从C中的第一个元素开始，每一项和前一项相加)</li><li>反向填充目标数组；将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1</li></ul><h3 id="动画演示-7"><a href="#动画演示-7" class="headerlink" title="动画演示"></a>动画演示</h3><p><img src="https://www.runoob.com/wp-content/uploads/2019/03/countingSort.gif" alt="计数排序"></p><h3 id="代码实现-7"><a href="#代码实现-7" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] countingSort(<span class="type">int</span>[] array)&#123;</span><br><span class="line">    <span class="comment">// 统计数组最大元素m</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> num : array) &#123;</span><br><span class="line">        m = Math.max(m,num);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 统计各个数字的出现次数</span></span><br><span class="line">    <span class="comment">// counter[num] 代表num的出现次数</span></span><br><span class="line">    <span class="type">int</span>[] counter = <span class="keyword">new</span> <span class="title class_">int</span>[m + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> num : array) &#123;</span><br><span class="line">        counter[num]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 求counter的前缀和，将“出现次数”转换成“尾索引”</span></span><br><span class="line">    <span class="comment">// 即counter[num] - 1是num在res中最后一次出现的索引</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; m; i++) &#123;</span><br><span class="line">        counter[i + <span class="number">1</span>] += counter[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 倒序遍历array，将各元素填入结果数组res</span></span><br><span class="line">    <span class="comment">// 初始化数组res用于记录结果</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> array.length;</span><br><span class="line">    <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> array[i];</span><br><span class="line">        <span class="comment">// 将num放置到对应索引处</span></span><br><span class="line">        res[counter[num] - <span class="number">1</span>] = num;</span><br><span class="line">        <span class="comment">// 令前缀和自减1，得到下次放置num的索引</span></span><br><span class="line">        counter[num]--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 使用结果数组res覆盖原数组array；</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; n; i++)&#123;</span><br><span class="line">        array[i] = res[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="算法分析-7"><a href="#算法分析-7" class="headerlink" title="算法分析"></a>算法分析</h3><p>当输入的元素是n个0到k之间的整数时，它的运行时间是O(n+k)。计数排序不是比较排序，排序的速度快于任何比较排序算法。由于用来计数的数组C的长度取决于待排序数组中数据的范围(等于待排序数组的最大值与最小值的差加上1)，这使得计数排序对应数据范围很大的数组，需要大量时间和内存。<br>最佳情况：T(n) = O(n+k)<br>最差情况：T(n) = O(n+k)<br>平均情况：T(n) = O(n+k)</p><p>空间复杂度：O(k)</p><p><br></p><h2 id="桶排序-Bucket-Sort"><a href="#桶排序-Bucket-Sort" class="headerlink" title="桶排序(Bucket Sort)"></a>桶排序(Bucket Sort)</h2><p>桶排序(Bucket Sort)是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的缺点。<br>桶排序的工作原理：假设输入数据服从均匀分布，将数据分到有限数量的桶里，每个桶再分别排序(有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排序)</p><h3 id="算法描述-8"><a href="#算法描述-8" class="headerlink" title="算法描述"></a>算法描述</h3><ul><li>人为设置一个BucketSize，作为每个桶所能放置多少个不同数值(例如当BucketSize==5时，该桶可以存放{1，2，3，4，5}这几种数字，但是容量不限，即可以存放100个3)；</li><li>遍历输入数据，并且把数据一个个放到对应的桶里去；</li><li>对每个不是空的桶进行排序，可以使用其他排序方法，也可以递归使用桶排序；</li><li>从不是空的桶里把排好序的数据拼接起来。<blockquote><p>注意，如果递归使用桶排序为各个桶排序，则当桶数量为1时要手动减小BucketSize增加下一循环桶的数量，否则会陷入死循环，导致内存溢出。</p></blockquote></li></ul><h3 id="图片演示"><a href="#图片演示" class="headerlink" title="图片演示"></a>图片演示</h3><p>元素分布在桶中：<br><img src="https://www.runoob.com/wp-content/uploads/2019/03/Bucket_sort_1.svg_.png" alt="桶排序1"><br>然后，元素在每个桶中排序：<br><img src="https://www.runoob.com/wp-content/uploads/2019/03/Bucket_sort_2.svg_.png" alt="桶排序2"></p><h3 id="代码实现-8"><a href="#代码实现-8" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] sort(<span class="type">int</span>[] sourceArray) &#123;</span><br><span class="line">    <span class="comment">// 对 arr 进行拷贝，不改变参数内容</span></span><br><span class="line">    <span class="type">int</span>[] arr = Arrays.copyOf(sourceArray, sourceArray.length);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> bucketSort(arr, <span class="number">5</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] bucketSort(<span class="type">int</span>[] arr, <span class="type">int</span> bucketSize) &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">minValue</span> <span class="operator">=</span> arr[<span class="number">0</span>];</span><br><span class="line">    <span class="type">int</span> <span class="variable">maxValue</span> <span class="operator">=</span> arr[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> value : arr) &#123;</span><br><span class="line">        <span class="keyword">if</span> (value &lt; minValue) &#123;</span><br><span class="line">            minValue = value;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value &gt; maxValue) &#123;</span><br><span class="line">            maxValue = value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">bucketCount</span> <span class="operator">=</span> (<span class="type">int</span>) Math.floor((maxValue - minValue) / bucketSize) + <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span>[][] buckets = <span class="keyword">new</span> <span class="title class_">int</span>[bucketCount][<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 利用映射函数将数据分配到各个桶中</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> (<span class="type">int</span>) Math.floor((arr[i] - minValue) / bucketSize);</span><br><span class="line">        buckets[index] = arrAppend(buckets[index], arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">arrIndex</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span>[] bucket : buckets) &#123;</span><br><span class="line">        <span class="keyword">if</span> (bucket.length &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 对每个桶进行排序，这里使用了插入排序</span></span><br><span class="line">        bucket = sort(bucket);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> value : bucket) &#123;</span><br><span class="line">            arr[arrIndex++] = value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自动扩容，并保存数据</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arr</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] arrAppend(<span class="type">int</span>[] arr, <span class="type">int</span> value) &#123;</span><br><span class="line">    arr = Arrays.copyOf(arr, arr.length + <span class="number">1</span>);</span><br><span class="line">    arr[arr.length - <span class="number">1</span>] = value;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="算法分析-8"><a href="#算法分析-8" class="headerlink" title="算法分析"></a>算法分析</h3><p>桶排序最好情况下使用线性时间O(n)，桶排序的时间复杂度，取决与对各个桶之间数据进行排序的时间复杂度，因为其它部分的时间复杂度都为O(n)。很显然，桶划分的越小，各个桶之间的数据越少，排序所用的时间也会越少。但相应的空间消耗就会增大。<br>最佳情况：T(n) = O(n+k)<br>最差情况：T(n) = O(n2)<br>平均情况：T(n) = O(n+k)</p><p>空间复杂度：O(n + k)</p><h2 id="基数排序-Radix-Sort"><a href="#基数排序-Radix-Sort" class="headerlink" title="基数排序(Radix Sort)"></a>基数排序(Radix Sort)</h2><p>基数排序(Radix Sort)也是非比较的排序算法，对每一位进行排序，从最低为开始排序，复杂度为O(kn)，n为数组长度，k为数组中的数的最大的位数；<br>基数排序是按照低位先排序，然后收集；再按照高位排序，然后再收集；依此类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序。最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前。基数排序基于分别排序，分别收集，所以是稳定的。</p><h3 id="算法描述-9"><a href="#算法描述-9" class="headerlink" title="算法描述"></a>算法描述</h3><ul><li>取得数组中的最大数，并取得位数</li><li>array为原始数组，从最低位开始取每个位组成radix数组；</li><li>对radix进行计数排序(利用计数排序适用于小范围数的特点)</li></ul><h3 id="动画演示-8"><a href="#动画演示-8" class="headerlink" title="动画演示"></a>动画演示</h3><p><img src="https://www.runoob.com/wp-content/uploads/2019/03/radixSort.gif" alt="基数排序"></p><h3 id="代码实现-9"><a href="#代码实现-9" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 获取元素 num 的第 k 位，其中 exp = 10^(k-1) */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">digit</span><span class="params">(<span class="type">int</span> num, <span class="type">int</span> exp)</span> &#123;</span><br><span class="line">    <span class="comment">// 传入 exp 而非 k 可以避免在此重复执行昂贵的次方计算</span></span><br><span class="line">    <span class="keyword">return</span> (num / exp) % <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 计数排序（根据 nums 第 k 位排序） */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">countingSortDigit</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> exp)</span> &#123;</span><br><span class="line">    <span class="comment">// 十进制的位范围为 0~9 ，因此需要长度为 10 的桶</span></span><br><span class="line">    <span class="type">int</span>[] counter = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>];</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">    <span class="comment">// 统计 0~9 各数字的出现次数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">d</span> <span class="operator">=</span> digit(nums[i], exp); <span class="comment">// 获取 nums[i] 第 k 位，记为 d</span></span><br><span class="line">        counter[d]++;                <span class="comment">// 统计数字 d 的出现次数</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 求前缀和，将“出现个数”转换为“数组索引”</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        counter[i] += counter[i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 倒序遍历，根据桶内统计结果，将各元素填入 res</span></span><br><span class="line">    <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">d</span> <span class="operator">=</span> digit(nums[i], exp);</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> counter[d] - <span class="number">1</span>; <span class="comment">// 获取 d 在数组中的索引 j</span></span><br><span class="line">        res[j] = nums[i];       <span class="comment">// 将当前元素填入索引 j</span></span><br><span class="line">        counter[d]--;           <span class="comment">// 将 d 的数量减 1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 使用结果覆盖原数组 nums</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        nums[i] = res[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 基数排序 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] radixSort(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">    <span class="comment">// 获取数组的最大元素，用于判断最大位数</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> Integer.MIN_VALUE;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> num : nums)</span><br><span class="line">        <span class="keyword">if</span> (num &gt; m)</span><br><span class="line">            m = num;</span><br><span class="line">    <span class="comment">// 按照从低位到高位的顺序遍历</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">exp</span> <span class="operator">=</span> <span class="number">1</span>; exp &lt;= m; exp *= <span class="number">10</span>)</span><br><span class="line">        <span class="comment">// 对数组元素的第 k 位执行计数排序</span></span><br><span class="line">        <span class="comment">// k = 1 -&gt; exp = 1</span></span><br><span class="line">        <span class="comment">// k = 2 -&gt; exp = 10</span></span><br><span class="line">        <span class="comment">// 即 exp = 10^(k-1)</span></span><br><span class="line">        countingSortDigit(nums, exp);</span><br><span class="line">    <span class="keyword">return</span> nums;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="算法分析-9"><a href="#算法分析-9" class="headerlink" title="算法分析"></a>算法分析</h3><p>最佳情况：T(n) = O(nk)<br>最差情况：T(n) = O(nk)<br>平均情况：T(n) = O(nk)</p><p>空间复杂度：O(n + k)</p><h2 id="基数排序-vs-计数排序-vs-桶排序"><a href="#基数排序-vs-计数排序-vs-桶排序" class="headerlink" title="基数排序 vs 计数排序 vs 桶排序"></a>基数排序 vs 计数排序 vs 桶排序</h2><p>这三种排序算法都利用了桶的概念，但对桶的使用方法上有明显差异：</p><ul><li>基数排序：根据键值的每位数字来分配桶；</li><li>计数排序：每个桶只存储单一键值；</li><li>桶排序：每个桶存储一定范围的数值；</li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>贪心算法</title>
      <link href="/posts/a4ce31d2.html"/>
      <url>/posts/a4ce31d2.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>回溯算法</title>
      <link href="/posts/376d0826.html"/>
      <url>/posts/376d0826.html</url>
      
        <content type="html"><![CDATA[<h1 id="回溯算法"><a href="#回溯算法" class="headerlink" title="回溯算法"></a>回溯算法</h1>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>二叉树</title>
      <link href="/posts/e85d694a.html"/>
      <url>/posts/e85d694a.html</url>
      
        <content type="html"><![CDATA[<h1 id="二叉树的基本理论"><a href="#二叉树的基本理论" class="headerlink" title="二叉树的基本理论"></a>二叉树的基本理论</h1><h2 id="从二叉树的总类"><a href="#从二叉树的总类" class="headerlink" title="从二叉树的总类"></a>从二叉树的总类</h2><p>特殊的二叉树主要有两种：满二叉树和完全二叉树</p><h3 id="满二叉树"><a href="#满二叉树" class="headerlink" title="满二叉树"></a>满二叉树</h3><p>满二叉树：二叉树只有结点为0的结点和度为2的结点，并且度为0的结点在同一层上<br>如下图<br><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20200806185805576.png" alt="满二叉树"><br>这棵树为满二叉树，深度为k时，有2^k-1个结点</p><h3 id="完全二叉树"><a href="#完全二叉树" class="headerlink" title="完全二叉树"></a>完全二叉树</h3><p>完全二叉树：出来最底层结点没有被填满外，其余层结点数都达到最大，且最下面一层结点是从最左边连续<br>最底层有1~2^(k-1)个结点<br><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20200920221638903.png" alt="完全二叉树"><br>优先级队列其实就是一个堆，堆就是一颗完全二叉树，同时保证父子结点的顺序关系</p><h3 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h3><p>二叉搜索树是一棵中序遍历有序的树</p><ul><li>左子树上结点小于根结点值</li><li>右子树上结点大于根结点值<br><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20200806190304693.png" alt="二叉搜索树"><br>如上两个都是二叉搜索树</li></ul><h3 id="平衡二叉搜索树"><a href="#平衡二叉搜索树" class="headerlink" title="平衡二叉搜索树"></a>平衡二叉搜索树</h3><p>平衡二叉搜索树: 也称AVL(Adelson-Velsky and Landis)树，它左右两个树的高度差绝对值不超过1，且左右两棵<br>子树都是平衡二叉树。n个结点的平衡二叉搜索树高度可保持在 O(logN)，搜索时间复杂度O(logN )<br><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20200806190511967.png" alt="平衡二叉搜索树"><br>最后一棵不是因为高度差绝对值超过了1.</p><p>java中map和set底层实现是红黑树，这个以后找个篇章特意写吧！</p><h2 id="二叉树的存储方式"><a href="#二叉树的存储方式" class="headerlink" title="二叉树的存储方式"></a>二叉树的存储方式</h2><blockquote><p>二叉树可以链式存储，也可以顺序存储。链式存储使用指针，顺序存储使用数组</p></blockquote><p><code>链式存储数据结构</code></p><pre><code>public class TreeNode &#123;    int val;    TreeNode left;    TreeNode right;    public TreeNode()&#123;    &#125;    public TreeNode(int val)&#123;        this.val = val;    &#125;    public TreeNode(int val,TreeNode left,TreeNode right)&#123;        this.val = val;        this.left = left;        this.right = right;    &#125;&#125;</code></pre><blockquote><p>当使用数组存储二叉树时，若父节点下标是i，则其左孩子下标为2i+1，右孩子为2i+2。</p></blockquote><p><code>在Java中输入数组使其构成树</code></p><pre><code>public class Solution &#123;    static class TreeNode&#123;        int val;        TreeNode left;        TreeNode right;        public TreeNode()&#123;&#125;        public TreeNode(int val)&#123;            this.val = val;            this.left = null;            this.right = null;        &#125;    &#125;    public static void main(String[] args) &#123;        int[] arr = new int[7];        Scanner in = new Scanner(System.in);        for (int i = 0;i &lt; arr.length;i++)&#123;            arr[i] = in.nextInt();        &#125;        Solution solution = new Solution();        TreeNode root = solution.constructBinaryTree(arr);        System.out.println(root.right.right.val);    &#125;    public TreeNode constructBinaryTree(final int[] arr)&#123;        // 初始树        List&lt;TreeNode&gt; treeNodeList = arr.length &gt; 0 ? new ArrayList&lt;&gt;(arr.length) : null;        TreeNode root = null;        // 给树各个结点赋值        for (int i = 0;i &lt; arr.length;i++)&#123;            TreeNode node = null;            if (arr[i] != -1)&#123;                node = new TreeNode(arr[i]);            &#125;            treeNodeList.add(node);            if (i == 0)&#123;                root = node;            &#125;        &#125;        // 指定树结点的左右孩子        for (int i = 0;i * 2 + 1&lt;arr.length;i++)&#123;            TreeNode node = treeNodeList.get(i);            if (node != null)&#123;                // 左孩子2i+1                node.left = treeNodeList.get(2 * i + 1);                // 右孩子2i+2                if (i * 2 + 2 &lt; arr.length)&#123;                    node.right = treeNodeList.get(2 * i + 2);                &#125;            &#125;        &#125;        return root;    &#125;&#125;</code></pre><h2 id="二叉树的遍历方式"><a href="#二叉树的遍历方式" class="headerlink" title="二叉树的遍历方式"></a>二叉树的遍历方式</h2><blockquote><p>二叉树主要有两种遍历方式：</p><ol><li>深度优先遍历：先往深走，遇到叶子结点再往回走<ul><li>前序遍历(递归法，迭代法)</li><li>中序遍历(递归法，迭代法)</li><li>后序遍历(递归法，迭代法)</li></ul></li><li>广度优先遍历：一层一层的去遍历<ul><li>层次遍历(递归法，迭代法)</li></ul></li></ol></blockquote><h3 id="二叉树的深度优先遍历"><a href="#二叉树的深度优先遍历" class="headerlink" title="二叉树的深度优先遍历"></a>二叉树的深度优先遍历</h3><blockquote><p>主要记录深度优先的递归法，迭代法可以借助栈来实现<br>在进行递归时也会使用到栈，但是这个栈是由内存自己为我们分配的</p><p>二叉树的前序遍历是从上往下的遍历方式</p></blockquote><p><code>前序遍历的递归法</code></p><pre><code>public List&lt;Integer&gt; preorderTraversal(TreeNode root)&#123;    List&lt;Integer&gt; res = new ArrayList&lt;&gt;();    preorder(root,res);    return res;&#125;public void preorder(TreeNode root,List&lt;Integer&gt; res)&#123;    if (root == null)&#123;        return;    &#125;    res.add(root.val);    preorder(root.left,res);    preorder(root.right,res);&#125;</code></pre><blockquote><p>二叉搜索树的中序遍历是有序的</p></blockquote><p><code>中序遍历的递归法</code></p><pre><code>public List&lt;Integer&gt; inorderTraversal(TreeNode root) &#123;    List&lt;Integer&gt; res = new ArrayList&lt;&gt;();    inorder(root, res);    return res;&#125;public void inorder(TreeNode root, List&lt;Integer&gt; res) &#123;    if (root == null) &#123;        return;    &#125;    inorder(root.left, res);    res.add(root.val);    inorder(root.right, res);&#125;</code></pre><blockquote><p>二叉树的后序遍历是从下往上的遍历方式</p></blockquote><p><code>后序遍历的递归法</code></p><pre><code>public List&lt;Integer&gt; postorderTraversal(TreeNode root) &#123;    List&lt;Integer&gt; res = new ArrayList&lt;&gt;();    postorder(root, res);    return res;&#125;public void postorder(TreeNode root, List&lt;Integer&gt; res) &#123;    if (root == null) &#123;        return;    &#125;    preorder(root.left, res);    preorder(root.right, res);    res.add(root.val);&#125;</code></pre><h3 id="二叉树的广度优先遍历"><a href="#二叉树的广度优先遍历" class="headerlink" title="二叉树的广度优先遍历"></a>二叉树的广度优先遍历</h3><blockquote><p>广度优先遍历也可使用递归法与迭代法<br>递归法是每一层作为一个递归<br>迭代法则是借助队列</p></blockquote><p><code>二叉树的广度优先遍历</code></p><pre><code>List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;    levelOne(root, 0);    levelTwo(root);    return res;&#125;// 递归法public void levelOne(TreeNode root, int depth) &#123;    if (root == null) &#123;        return;    &#125;    depth++;    if (res.size() &lt; depth) &#123;        List&lt;Integer&gt; item = new ArrayList&lt;&gt;();        res.add(item);    &#125;    res.get(depth - 1).add(root.val);    levelOne(root.left, depth);    levelOne(root.right, depth);&#125;// 迭代法，借助队列public void levelTwo(TreeNode root) &#123;    if (root == null) &#123;        return;    &#125;    Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;();    queue.offer(root);    while (!queue.isEmpty()) &#123;        List&lt;Integer&gt; item = new ArrayList&lt;&gt;();        int len = queue.size();        while (len &gt; 0) &#123;            TreeNode temp = queue.poll();            item.add(temp.val);            if (temp.left != null) &#123;                queue.offer(temp.left);            &#125;            if (temp.right != null) &#123;                queue.offer(temp.right);            &#125;            len--;        &#125;        res.add(item);    &#125;&#125;</code></pre><blockquote><p>对于二叉树的相关特征以及算法主要有以下</p></blockquote><h2 id="二叉树的属性"><a href="#二叉树的属性" class="headerlink" title="二叉树的属性"></a>二叉树的属性</h2><h3 id="1-二叉树是否对称-101-对称二叉树"><a href="#1-二叉树是否对称-101-对称二叉树" class="headerlink" title="(1)二叉树是否对称:101.对称二叉树"></a><a href="https://leetcode.cn/problems/symmetric-tree/">(1)二叉树是否对称:101.对称二叉树</a></h3><p>给定一个二叉树，判断其是不是对称的，如下图<br><img src="https://assets.leetcode.com/uploads/2021/02/19/symtree1.jpg" alt="二叉树"></p><blockquote><p>判断一棵树是不是轴对称，既是判断根节点的左子树和右子树是不是翻转的，也就是左的左是否等于右的右，<br>左的右是不是等于右的左，使用递归对每个结点进行判断；<br>也可以借助队列，将左右结点按照顺序放入队列中进行比较。</p></blockquote><p><code>递归法</code></p><pre><code>public boolean isSymmetric(TreeNode root) &#123;    return compare(root.left,root.right);&#125;public boolean compare(TreeNode left,TreeNode right)&#123;    if (left == null &amp;&amp; right != null)&#123;        return false;    &#125;    if (left != null &amp;&amp; right == null)&#123;        return false;    &#125;    if (left == null &amp;&amp; right == null)&#123;        return true;    &#125;    if (left.val != right.val)&#123;        return false;    &#125;    // 比较外侧    boolean outside = compare(left.left,right.right);    // 比较内侧    boolean inside = compare(left.right,right.left);    return outside &amp;&amp; inside;&#125;</code></pre><p><code>迭代法</code></p><pre><code>public boolean isSymmetric(TreeNode root) &#123;    Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;();    queue.offer(root.left);    queue.offer(root.right);    while (!queue.isEmpty())&#123;        TreeNode left = queue.poll();        TreeNode right = queue.poll();        if (left == null &amp;&amp; right == null)&#123;            continue;        &#125;        if (left == null || right == null || left.val != right.val)&#123;            return false;        &#125;        // 按照左左，右右，左右，右左顺序加入队列        queue.offer(left.left);        queue.offer(right.right);        queue.offer(left.right);        queue.offer(right.left);    &#125;    return true;&#125;</code></pre><h3 id="2-求二叉树的最大深度和最小深度"><a href="#2-求二叉树的最大深度和最小深度" class="headerlink" title="(2)求二叉树的最大深度和最小深度"></a>(2)求二叉树的最大深度和最小深度</h3><p><a href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/">最大深度</a><br><a href="https://leetcode.cn/problems/minimum-depth-of-binary-tree/">最小深度</a></p><blockquote><p>求最大深度，通过递归法，递归返回的值即是树的深度，也可以同迭代法进行层序遍历，每遍历一层将depth++；<br>求最小深度，通过递归法，找到第一个左右结点都为空的结点即为最小深度结点；通过迭代法进行层序遍历，第一个左右结点都为空<br>的结点即为最小深度结点。</p></blockquote><p><code>最大深度递归法</code></p><pre><code>public int maxDepth(TreeNode root) &#123;    if (root == null) &#123;        return 0;    &#125; else &#123;        int left = maxDepth(root.left);        int right = maxDepth(root.right);        return Math.max(left, right) + 1;    &#125; &#125;</code></pre><p><code>最大深度迭代法</code></p><pre><code>public int maxDepth(TreeNode root) &#123;    if (root == null)&#123;        return 0;    &#125;    Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;();    queue.offer(root);    int deep = 0;    while (!queue.isEmpty())&#123;        int len = queue.size();        while (len &gt; 0)&#123;            TreeNode temp = queue.poll();            if (temp.left != null)&#123;                queue.offer(temp.left);            &#125;            if (temp.right != null) &#123;                queue.offer(temp.right);            &#125;            len--;        &#125;        // 借助队列，没迭代一层之后深度++；        deep++;    &#125;    return deep;&#125;</code></pre><p><code>最小深度递归法</code></p><pre><code>public int minDepth(TreeNode root) &#123;    if (root == null) &#123;        return 0;    &#125;    int leftDepth = minDepth(root.left);    int rightDepth = minDepth(root.right);    if (root.left == null) &#123;        return rightDepth + 1;    &#125;    if (root.right == null) &#123;        return leftDepth + 1;    &#125;    // 左右结点都不为null    return Math.min(leftDepth, rightDepth) + 1;&#125;</code></pre><p><code>最小深度迭代法</code></p><pre><code>public int minDepth(TreeNode root) &#123;    if(root == null)&#123;        return 0;    &#125;    Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;();    queue.offer(root);    int depth = 0;    while (!queue.isEmpty())&#123;        int len = queue.size();        depth++;        TreeNode temp = null;        while (len &gt; 0)&#123;            temp = queue.poll();            // 当遇到第一个左右结点都为空的直接返回。            if (temp.left == null &amp;&amp; temp.right==null)&#123;                return depth;            &#125;            if (temp.left != null)&#123;                queue.offer(temp.left);            &#125;            if (temp.right != null)&#123;                queue.offer(temp.right);            &#125;            len--;        &#125;    &#125;    return depth;&#125;</code></pre><h3 id="3-求二叉树结点个数"><a href="#3-求二叉树结点个数" class="headerlink" title="(3)求二叉树结点个数"></a><a href="https://leetcode.cn/problems/count-complete-tree-nodes/">(3)求二叉树结点个数</a></h3><blockquote><p>直接通过递归法，递归次数即为结点个数<br>也可以借助队列，队列中每加入一个结点，则结点总个数++</p></blockquote><p><code>递归法</code></p><pre><code>public int countNodes(TreeNode root) &#123;    if (root == null)&#123;        return 0;    &#125;    return countNodes(root.left) + countNodes(root.right) + 1;&#125;</code></pre><p><code>迭代法</code></p><pre><code>public int countNodes(TreeNode root) &#123;    if (root == null)&#123;        return 0;    &#125;    Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;();    queue.offer(root);    int result = 0;    while (!queue.isEmpty())&#123;        int len = queue.size();        while (len &gt; 0)&#123;            TreeNode temp = queue.poll();            // 统计结点个数            result++;            if (temp.left != null)&#123;                queue.offer(temp.left);            &#125;            if (temp.right != null)&#123;                queue.offer(temp.right);            &#125;            len--;        &#125;    &#125;    return result;&#125;</code></pre><h3 id="4-二叉树是否平衡"><a href="#4-二叉树是否平衡" class="headerlink" title="(4)二叉树是否平衡"></a><a href="https://leetcode.cn/problems/balanced-binary-tree/">(4)二叉树是否平衡</a></h3><blockquote><p>判断二叉树是否平衡即每一个结点都需要进行判断，对每一个结点进行左右子树高度比较，所以我们可以通过<br>后序遍历来做,使用-1做为不平衡的标志</p></blockquote><p><code>递归后序遍历</code></p><pre><code>public boolean isBalanced(TreeNode root) &#123;    return getHeight(root) != -1;&#125;private int getHeight(TreeNode root) &#123;    if (root == null) &#123;        return 0;    &#125;    int leftHeight = getHeight(root.left);    if (leftHeight == -1) &#123;        return -1;    &#125;    int rightHeight = getHeight(root.right);    if (rightHeight == -1) &#123;        return -1;    &#125;    // 左右子树高度差大于1，return -1表示已经不是平衡树了    if (Math.abs(leftHeight - rightHeight) &gt; 1) &#123;        return -1;    &#125;    return Math.max(leftHeight, rightHeight) + 1;&#125;</code></pre><h3 id="5-求所有路径"><a href="#5-求所有路径" class="headerlink" title="(5)求所有路径"></a><a href="https://leetcode.cn/problems/binary-tree-paths/">(5)求所有路径</a></h3><blockquote><p>求根节点到所有叶子结点的路径，可以很简单的使用深度优先遍历直到叶子结点<br>使用前序遍历使父节点指向子节点，直到子节点的左右孩子都为空<br>也可以使用迭代法，借助栈，非空时一直往站内添加元素</p></blockquote><p><code>递归法</code></p><pre><code>public List&lt;String&gt; binaryTreePaths(TreeNode root) &#123;    List&lt;String&gt; res = new ArrayList&lt;&gt;();    if (root == null)&#123;        return res;    &#125;    dfs(root,&quot;&quot;,res);    return res;&#125;public void dfs(TreeNode node,String path,List&lt;String&gt; res)&#123;    if (node != null)&#123;        StringBuffer sb = new StringBuffer(path);        sb.append(Integer.toString(node.val));        if (node.left == null &amp;&amp; node.right==null)&#123;            res.add(sb.toString());        &#125; else &#123;          sb.append(&quot;-&gt;&quot;);          dfs(node.left,sb.toString(),res);          dfs(node.right,sb.toString(),res);        &#125;    &#125;&#125;</code></pre><p><code>迭代法</code></p><pre><code>public List&lt;String&gt; binaryTreePaths(TreeNode root) &#123;    if (root == null)&#123;        return null;    &#125;    List&lt;String&gt; res = new ArrayList&lt;&gt;();    Stack&lt;Object&gt; stack = new Stack&lt;&gt;();    // 节点和路径同时入栈    stack.push(root);    stack.push(root.val + &quot;&quot;);    while (!stack.isEmpty())&#123;        // 节点和路径同时出栈        String path = (String) stack.pop();        TreeNode node = (TreeNode) stack.pop();        // 若找到叶子节点        if (node.left == null &amp;&amp; node.right==null)&#123;            res.add(path);        &#125;        //右子节点不为空        if (node.right!=null)&#123;            stack.push(node.right);            stack.push(path + &quot;-&gt;&quot; + node.right.val);        &#125;        //左子节点不为空        if (node.left != null)&#123;            stack.push(node.left);            stack.push(path + &quot;-&gt;&quot; + node.left.val);        &#125;    &#125;    return res;&#125;</code></pre><h3 id="6-求左叶子的和"><a href="#6-求左叶子的和" class="headerlink" title="(6)求左叶子的和"></a><a href="https://leetcode.cn/problems/sum-of-left-leaves/">(6)求左叶子的和</a></h3><blockquote><p>某一结点是左叶子的条件是此结点是一结点的左结点且左结点没有左右孩子<br>根据这一条件就可以很轻松的通过迭代法或递归法来求左叶子的和</p></blockquote><p><code>递归法</code></p><pre><code>public int sumOfLeftLeaves(TreeNode root) &#123;    if (root == null)&#123;        return 0;    &#125;    int leftValue = sumOfLeftLeaves(root.left);  //左    int rightValue = sumOfLeftLeaves(root.right); //右    int midValue = 0;    if (root.left != null &amp;&amp; root.left.left == null &amp;&amp; root.left.right == null)&#123;        midValue = root.left.val;    &#125;    int sum = leftValue + rightValue + midValue;    return sum;&#125;</code></pre><p><code>迭代法</code></p><pre><code>public int sumOfLeftLeaves(TreeNode root) &#123;    int res = 0;    if (root == null)&#123;        return res;    &#125;    Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;();    queue.offer(root);    while (!queue.isEmpty())&#123;        int len = queue.size();        while (len &gt; 0)&#123;            TreeNode temp = queue.poll();            // 判断叶子结点            if (temp.left != null &amp;&amp; temp.left.left == null &amp;&amp; temp.left.right ==null)&#123;                res = res + temp.left.val;            &#125;            if (temp.left != null)&#123;                queue.offer(temp.left);            &#125;            if (temp.right != null)&#123;                queue.offer(temp.right);            &#125;            len--;        &#125;    &#125;    return res;&#125;</code></pre><h2 id="二叉树的修改与改造"><a href="#二叉树的修改与改造" class="headerlink" title="二叉树的修改与改造"></a>二叉树的修改与改造</h2><h3 id="1-翻转二叉树"><a href="#1-翻转二叉树" class="headerlink" title="(1)翻转二叉树"></a><a href="https://leetcode.cn/problems/invert-binary-tree/">(1)翻转二叉树</a></h3><blockquote><p>使用递归法前序遍历交换左右孩子，或使用迭代法借助队列模拟前序遍历</p></blockquote><p><code>递归法</code></p><pre><code>/** * 前后序遍历都可以 * 中序不行，因为先左孩子交换孩子，再根交换孩子（做完后，右孩子已经变成了原来的左孩子）， * 再右孩子交换孩子（此时其实是对原来的左孩子做交换） */public TreeNode invertTree(TreeNode root) &#123;    reverse(root);    return root;&#125;public void reverse(TreeNode node)&#123;    if (node == null)&#123;        return;    &#125;    TreeNode temp = node.left;    node.left = node.right;    node.right = temp;    reverse(node.left);    reverse(node.right);&#125;</code></pre><p><code>迭代法</code></p><pre><code>public TreeNode invertTree(TreeNode root) &#123;    if (root == null)&#123;        return null;    &#125;    ArrayDeque&lt;TreeNode&gt; deque = new ArrayDeque&lt;&gt;();    deque.offer(root);    while (!deque.isEmpty())&#123;        int size = deque.size();        while (size-- &gt; 0)&#123;            TreeNode node = deque.poll();            swap(node);            if (node.left != null)&#123;                deque.offer(node.left);            &#125;            if (node.right != null)&#123;                deque.offer(node.right);            &#125;        &#125;    &#125;    return root;&#125;public void swap(TreeNode root)&#123;    TreeNode temp = root.left;    root.left = root.right;    root.right = temp;&#125;</code></pre><h3 id="2-构造二叉树"><a href="#2-构造二叉树" class="headerlink" title="(2)构造二叉树"></a><a href="https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/">(2)构造二叉树</a></h3><blockquote><p>给定两个整数数组 inorder 和 postorder ，其中 inorder 是二叉树的中序遍历，<br>postorder 是同一棵树的后序遍历，构造并返回这颗二叉树。<br><img src="https://i.328888.xyz/2023/04/17/ieNd8L.jpeg" alt="中序后序"><br>如上图所画在后序遍历中最后一个结点即为根结点，对应中序遍历，3的左边即为左子树，右边即为右子树<br>后序遍历根结点前一个结点即为右子树第一个结点，右子树所有结点前一个结点即为左子树第一个结点，对应<br>到中序遍历根据父节点依次寻找子节点</p></blockquote><pre><code>Map&lt;Integer, Integer&gt; map;  // 方便根据数值查找位置public TreeNode buildTree(int[] inorder, int[] postorder) &#123;    map = new HashMap&lt;&gt;();    for (int i = 0; i &lt; inorder.length; i++) &#123; // 用map保存中序序列的数值对应位置        map.put(inorder[i], i);    &#125;    return findNode(inorder,  0, inorder.length, postorder,0, postorder.length);  // 前闭后开&#125;public TreeNode findNode(int[] inorder, int inBegin, int inEnd, int[] postorder, int postBegin, int postEnd) &#123;    // 参数里的范围都是前闭后开    if (inBegin &gt;= inEnd || postBegin &gt;= postEnd) &#123;  // 不满足左闭右开，说明没有元素，返回空树        return null;    &#125;    int rootIndex = map.get(postorder[postEnd - 1]);  // 找到后序遍历的最后一个元素在中序遍历中的位置    TreeNode root = new TreeNode(inorder[rootIndex]);  // 构造结点    int lenOfLeft = rootIndex - inBegin;  // 保存中序左子树个数，用来确定后序数列的个数    root.left = findNode(inorder, inBegin, rootIndex,                        postorder, postBegin, postBegin + lenOfLeft);    root.right = findNode(inorder, rootIndex + 1, inEnd,                        postorder, postBegin + lenOfLeft, postEnd - 1);    return root;&#125;</code></pre><h3 id="3-构造最大二叉树"><a href="#3-构造最大二叉树" class="headerlink" title="(3)构造最大二叉树"></a><a href="https://leetcode.cn/problems/maximum-binary-tree/">(3)构造最大二叉树</a></h3><blockquote><p>给定一个不重复的整数数组 nums 。 最大二叉树 可以用下面的算法从 nums 递归地构建:<br>创建一个根节点，其值为 nums 中的最大值。<br>递归地在最大值 左边 的 子数组前缀上 构建左子树。<br>递归地在最大值 右边 的 子数组后缀上 构建右子树。</p><p>这个题通过递归可以很快的做出来，即找到最大值做根，左边做左子树，右边做右子树</p></blockquote><p><code>迭代法</code></p><pre><code>public TreeNode constructMaximumBinaryTree(int[] nums) &#123;    return constructMaximumBinaryTree1(nums, 0, nums.length);&#125;public TreeNode constructMaximumBinaryTree1(int[] nums, int leftIndex, int rightIndex) &#123;    if (rightIndex - leftIndex &lt; 1) &#123;// 没有元素了        return null;    &#125;    if (rightIndex - leftIndex == 1) &#123;// 只有一个元素        return new TreeNode(nums[leftIndex]);    &#125;    int maxIndex = leftIndex;// 最大值所在位置    int maxVal = nums[maxIndex];// 最大值    for (int i = leftIndex + 1; i &lt; rightIndex; i++) &#123;        if (nums[i] &gt; maxVal)&#123;            maxVal = nums[i];            maxIndex = i;        &#125;    &#125;    TreeNode root = new TreeNode(maxVal);    // 根据maxIndex划分左右子树    root.left = constructMaximumBinaryTree1(nums, leftIndex, maxIndex);    root.right = constructMaximumBinaryTree1(nums, maxIndex + 1, rightIndex);    return root;&#125;</code></pre><blockquote><p>而另外一种方式则是通过单调栈<br>我们我们通过递归操作的时候，会发现虽然每次都对数组进行了拆分操作，但是，对数组中的元素也会进行多次的重复遍历，那么有没有一种方式，可以仅通过对数组nums的一次遍历，就可以得出最终结果的呢？ 其实有的，我们可以通过单调栈的方式进行操作。<br>采用单调栈的基本思路是这样的：</p><ol><li>如果栈顶元素大于待插入的元素，那么直接入栈。</li><li>如果栈顶元素小于待插入的元素，那么栈顶元素出栈。</li></ol><p>当然，在对比两个节点大小和出入栈的同时，依然还是会根据题意，进行二叉树的构造。即：</p><ul><li>如果栈顶元素大于待插入的元素，则：栈顶元素.right = 待插入元素。</li><li>如果栈顶元素小于待插入的元素，则：待插入元素.left = 栈顶元素。<br>我们依然以nums = [3,2,1,6,0,5]为例，看一下通过单调栈是怎么创建二叉树的。<br><img src="https://pic.leetcode-cn.com/1660983422-ivHnrW-1.png" alt="1"><br><img src="https://pic.leetcode-cn.com/1660983435-LSVAnP-1.png" alt="2"><br><img src="https://pic.leetcode-cn.com/1660983451-ofGVFw-1.png" alt="3"><br><img src="https://pic.leetcode-cn.com/1660983463-ErjdMy-1.png" alt="4"></li></ul></blockquote><p><code>单调栈</code></p><pre><code>public TreeNode constructMaximumBinaryTree(int[] nums) &#123;    Deque&lt;TreeNode&gt; deque = new ArrayDeque();    for (int i = 0; i &lt; nums.length; i++) &#123;        TreeNode node = new TreeNode(nums[i]);        while(!deque.isEmpty()) &#123;            TreeNode topNode = deque.peekLast();            if (topNode.val &gt; node.val) &#123;                deque.addLast(node);                topNode.right = node;                break;            &#125; else &#123;                deque.removeLast(); // 出栈操作                node.left = topNode;            &#125;        &#125;        if (deque.isEmpty()) deque.addLast(node);    &#125;    return deque.peek();&#125;</code></pre><h2 id="二叉搜索树的属性"><a href="#二叉搜索树的属性" class="headerlink" title="二叉搜索树的属性"></a>二叉搜索树的属性</h2><h3 id="1-是不是二叉搜索树"><a href="#1-是不是二叉搜索树" class="headerlink" title="(1)是不是二叉搜索树"></a><a href="https://leetcode.cn/problems/validate-binary-search-tree/">(1)是不是二叉搜索树</a></h3><blockquote><p>给定一个二叉树的根节点 root ，判断其是否是一个有效的二叉搜索树。<br>有效二叉搜索树定义如下：</p><ul><li>节点的左子树只包含 小于 当前节点的数。</li><li>节点的右子树只包含 大于 当前节点的数。</li><li>所有左子树和右子树自身必须也是二叉搜索树。</li></ul><p>二叉搜索树的中序遍历得到的是一个有序的，所以只需要中序遍历之后判断后一个结点是不是比前一个结点值大</p></blockquote><pre><code>long pre = Long.MIN_VALUE;public boolean isValidBST(TreeNode root) &#123;    return inorder(root);&#125;public boolean inorder(TreeNode node)&#123;    if (node == null)&#123;        return true;    &#125;    boolean l = inorder(node.left);    if (node.val &lt;= pre)&#123;        return false;    &#125;    pre = node.val;    boolean r = inorder(node.right);    return l&amp;&amp;r;&#125;</code></pre><h3 id="2-求二叉搜索树的众数"><a href="#2-求二叉搜索树的众数" class="headerlink" title="(2)求二叉搜索树的众数"></a><a href="https://leetcode.cn/problems/find-mode-in-binary-search-tree/">(2)求二叉搜索树的众数</a></h3><blockquote><p>给你一个含重复值的二叉搜索树（BST）的根节点 root ，找出并返回 BST 中的所有 众数（即，出现频率最高的元素）。<br>如果树中有不止一个众数，可以按 任意顺序 返回。<br>假定 BST 满足如下定义：</p><ul><li>结点左子树中所含节点的值 小于等于 当前节点的值</li><li>结点右子树中所含节点的值 大于等于 当前节点的值</li><li>左子树和右子树都是二叉搜索树</li></ul><p>二叉搜索树的中序遍历是有序的，用hash表做中序遍历用node.val做key，用相同的个数做value，输出个数最大的即可</p></blockquote><pre><code>Map&lt;Integer,Integer&gt; map = new HashMap&lt;&gt;();public int[] findMode(TreeNode root) &#123;    if (root == null)&#123;        return new int[0];    &#125;    inorder(root);    List&lt;Integer&gt; list = new ArrayList&lt;&gt;();    List&lt;Map.Entry&lt;Integer, Integer&gt;&gt; mapList = map.entrySet().stream()            .sorted((c1, c2) -&gt; c2.getValue().compareTo(c1.getValue()))            .collect(Collectors.toList());    list.add(mapList.get(0).getKey());    // 把频率最高的加入 list    for (int i = 1; i &lt; mapList.size(); i++) &#123;        if (mapList.get(i).getValue() == mapList.get(i - 1).getValue()) &#123;            list.add(mapList.get(i).getKey());        &#125; else &#123;            break;        &#125;    &#125;    return list.stream().mapToInt(Integer::intValue).toArray();&#125;public void inorder(TreeNode node)&#123;    if (node == null)&#123;        return;    &#125;    inorder(node.left);    map.put(node.val, map.getOrDefault(node.val,0)+1);    inorder(node.right);&#125;</code></pre><blockquote><p>也可以利用二叉搜索树的特性，将数使用count来进行计数，使用maxCount记录出现的最大次数，<br>相等则加入结果数组，当count大于maxCount时表明出现了新的最大次数的数，清除结果数组中所有<br>的数更新maxCount</p></blockquote><pre><code>ArrayList&lt;Integer&gt; resList;int maxCount;int count;TreeNode pre;public int[] findMode(TreeNode root) &#123;    resList = new ArrayList&lt;&gt;();    maxCount = 0;    count = 0;    pre = null;    findMode1(root);    int[] res = new int[resList.size()];    for (int i = 0; i &lt; resList.size(); i++) &#123;        res[i] = resList.get(i);    &#125;    return res;&#125;public void findMode1(TreeNode root) &#123;    if (root == null) &#123;        return;    &#125;    findMode1(root.left);    int rootValue = root.val;    // 计数    if (pre == null || rootValue != pre.val) &#123;        count = 1;    &#125; else &#123;        count++;    &#125;    // 更新结果以及maxCount    if (count &gt; maxCount) &#123;        resList.clear();        resList.add(rootValue);        maxCount = count;    &#125; else if (count == maxCount) &#123;        resList.add(rootValue);    &#125;    pre = root;    findMode1(root.right);&#125;</code></pre><h2 id="二叉树公共祖先问题"><a href="#二叉树公共祖先问题" class="headerlink" title="二叉树公共祖先问题"></a>二叉树公共祖先问题</h2><p><a href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/">二叉树的最近公共祖先</a></p><blockquote><p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。<br>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，<br>满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</p><p>使用后序遍历从而能先知道两个结点位置从而找到最近公共祖先</p></blockquote><pre><code>public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) &#123;   if (root == null || root == p || root == q)&#123;        return root;    &#125;    TreeNode left = lowestCommonAncestor(root.left,p,q);    TreeNode right = lowestCommonAncestor(root.right,p,q);    if (right == null)&#123;        return left;    &#125;    if (left == null)&#123;        return right;    &#125;    return root;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>开始</title>
      <link href="/posts/0.html"/>
      <url>/posts/0.html</url>
      
        <content type="html"><![CDATA[<h1 id="记录"><a href="#记录" class="headerlink" title="记录"></a>记录</h1><div class="tip info"><ul><li>无回顾，不成长 </li></ul></div>]]></content>
      
      
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title></title>
      <link href="/manifest.json"/>
      <url>/manifest.json</url>
      
        <content type="html"><![CDATA[{"name":"LIFE","short_name":"WENJD","theme_color":"#3b70fc","background_color":"#3b70fc","display":"standalone","scope":"/","start_url":"/","icons":[{"src":"/img/siteicon/16.png","sizes":"16x16","type":"image/png"},{"src":"/img/siteicon/32.png","sizes":"32x32","type":"image/png"},{"src":"/img/siteicon/48.png","sizes":"48x48","type":"image/png"},{"src":"/img/siteicon/64.png","sizes":"64x64","type":"image/png"},{"src":"/img/siteicon/128.png","sizes":"128x128","type":"image/png"},{"src":"/img/siteicon/144.png","sizes":"144x144","type":"image/png"},{"src":"/img/siteicon/512.png","sizes":"512x512","type":"image/png"}],"splash_pages":null}]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>分类</title>
      <link href="/categories/index.html"/>
      <url>/categories/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/css/custom.css"/>
      <url>/css/custom.css</url>
      
        <content type="html"><![CDATA[/* @font-face {  font-family: Candyhome;  src: url(https://npm.elemecdn.com/anzhiyu-blog@1.1.6/fonts/Candyhome.ttf);  font-display: swap;  font-weight: lighter;} */@font-face {    font-family: ZhuZiAYuanJWD;    src: url(https://npm.elemecdn.com/anzhiyu-blog@1.1.6/fonts/ZhuZiAWan.woff2);    font-display: swap;    font-weight: lighter;  }    div#menus {    font-family: "ZhuZiAYuanJWD";  }  h1#site-title {    font-family: ZhuZiAYuanJWD;    font-size: 3em !important;  }  a.article-title,  a.blog-slider__title,  a.categoryBar-list-link,  h1.post-title {    font-family: ZhuZiAYuanJWD;  }    .iconfont {    font-family: "iconfont" !important;    font-size: 3em;    /* 可以定义图标大小 */    font-style: normal;    -webkit-font-smoothing: antialiased;    -moz-osx-font-smoothing: grayscale;  }    /* 时间轴生肖icon */  svg.icon {    /* 这里定义svg.icon，避免和Butterfly自带的note标签冲突 */    width: 1em;    height: 1em;    /* width和height定义图标的默认宽度和高度*/    vertical-align: -0.15em;    fill: currentColor;    overflow: hidden;  }    .icon-zhongbiao::before {    color: #f7c768;  }    /* bilibli番剧插件 */  #article-container .bangumi-tab.bangumi-active {    background: var(--anzhiyu-theme);    color: var(--anzhiyu-ahoverbg);    border-radius: 10px;  }  a.bangumi-tab:hover {    text-decoration: none !important;  }  .bangumi-button:hover {    background: var(--anzhiyu-theme) !important;    border-radius: 10px !important;    color: var(--anzhiyu-ahoverbg) !important;  }  a.bangumi-button.bangumi-nextpage:hover {    text-decoration: none !important;  }  .bangumi-button {    padding: 5px 10px !important;  }    a.bangumi-tab {    padding: 5px 10px !important;  }  svg.icon.faa-tada {    font-size: 1.1em;  }  .bangumi-info-item {    border-right: 1px solid #f2b94b;  }  .bangumi-info-item span {    color: #f2b94b;  }  .bangumi-info-item em {    color: #f2b94b;  }    /* 解决artitalk的图标问题 */  #uploadSource > svg {    width: 1.19em;    height: 1.5em;  }    /*top-img黑色透明玻璃效果移除，不建议加，除非你执着于完全一图流或者背景图对比色明显 */  #page-header:not(.not-top-img):before {    background-color: transparent !important;  }    /* 首页文章卡片 */  #recent-posts > .recent-post-item {    background: rgba(255, 255, 255, 0.9);  }    /* 首页侧栏卡片 */  #aside-content .card-widget {    background: rgba(255, 255, 255, 0.9);  }    /* 文章页面正文背景 */  div#post {    background: rgba(255, 255, 255, 0.9);  }    /* 分页页面 */  div#page {    background: rgba(255, 255, 255, 0.9);  }    /* 归档页面 */  div#archive {    background: rgba(255, 255, 255, 0.9);  }    /* 标签页面 */  div#tag {    background: rgba(255, 255, 255, 0.9);  }    /* 分类页面 */  div#category {    background: rgba(255, 255, 255, 0.9);  }    /*夜间模式伪类遮罩层透明*/  [data-theme="dark"] #recent-posts > .recent-post-item {    background: #121212;  }    [data-theme="dark"] .card-widget {    background: #121212 !important;  }    [data-theme="dark"] div#post {    background: #121212 !important;  }    [data-theme="dark"] div#tag {    background: #121212 !important;  }    [data-theme="dark"] div#archive {    background: #121212 !important;  }    [data-theme="dark"] div#page {    background: #121212 !important;  }    [data-theme="dark"] div#category {    background: #121212 !important;  }    [data-theme="dark"] div#category {    background: transparent !important;  }  /* 页脚透明 */  #footer {    background: transparent !important;  }    /* 头图透明 */  #page-header {    background: transparent !important;  }  #rightside > div > button {    border-radius: 5px;  }    /* 滚动条 */    ::-webkit-scrollbar {    width: 10px;    height: 10px;  }    ::-webkit-scrollbar-thumb {    background-color: #3b70fc;    border-radius: 2em;  }    ::-webkit-scrollbar-corner {    background-color: transparent;  }    ::-moz-selection {    color: #fff;    background-color: #3b70fc;  }    /* 音乐播放器 */    /* .aplayer .aplayer-lrc {    display: none !important;  } */    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body {    left: -66px !important;    transition: all 0.3s;    /* 默认情况下缩进左侧66px，只留一点箭头部分 */  }    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body:hover {    left: 0 !important;    transition: all 0.3s;    /* 鼠标悬停是左侧缩进归零，完全显示按钮 */  }    .aplayer.aplayer-fixed {    z-index: 999999 !important;  }    /* 评论框  */  .vwrap {    box-shadow: 2px 2px 5px #bbb;    background: rgba(255, 255, 255, 0.3);    border-radius: 8px;    padding: 30px;    margin: 30px 0px 30px 0px;  }    /* 设置评论框 */    .vcard {    box-shadow: 2px 2px 5px #bbb;    background: rgba(255, 255, 255, 0.3);    border-radius: 8px;    padding: 30px;    margin: 30px 0px 0px 0px;  }    /* md网站下划线 */  #article-container a:hover {    text-decoration: none !important;  }    #article-container #hpp_talk p img {    display: inline;  }    /* 404页面 */  #error-wrap {    position: absolute;    top: 40%;    right: 0;    left: 0;    margin: 0 auto;    padding: 0 1rem;    max-width: 1000px;    transform: translate(0, -50%);  }    #error-wrap .error-content {    display: flex;    flex-direction: row;    justify-content: center;    align-items: center;    margin: 0 1rem;    height: 18rem;    border-radius: 8px;    background: var(--card-bg);    box-shadow: var(--card-box-shadow);    transition: all 0.3s;  }    #error-wrap .error-content .error-img {    box-flex: 1;    flex: 1;    height: 100%;    border-top-left-radius: 8px;    border-bottom-left-radius: 8px;    background-color: #3b70fc;    background-position: center;    background-size: cover;  }    #error-wrap .error-content .error-info {    box-flex: 1;    flex: 1;    padding: 0.5rem;    text-align: center;    font-size: 14px;    font-family: Titillium Web, "PingFang SC", "Hiragino Sans GB", "Microsoft JhengHei", "Microsoft YaHei", sans-serif;  }  #error-wrap .error-content .error-info .error_title {    margin-top: -4rem;    font-size: 9em;  }  #error-wrap .error-content .error-info .error_subtitle {    margin-top: -3.5rem;    word-break: break-word;    font-size: 1.6em;  }  #error-wrap .error-content .error-info a {    display: inline-block;    margin-top: 0.5rem;    padding: 0.3rem 1.5rem;    background: var(--btn-bg);    color: var(--btn-color);  }    #body-wrap.error .aside-list {    display: flex;    flex-direction: row;    flex-wrap: nowrap;    bottom: 0px;    position: absolute;    padding: 1rem;    width: 100%;    overflow: scroll;  }    #body-wrap.error .aside-list .aside-list-group {    display: flex;    flex-direction: row;    flex-wrap: nowrap;    max-width: 1200px;    margin: 0 auto;  }    #body-wrap.error .aside-list .aside-list-item {    padding: 0.5rem;  }    #body-wrap.error .aside-list .aside-list-item img {    width: 100%;    object-fit: cover;    border-radius: 12px;  }    #body-wrap.error .aside-list .aside-list-item .thumbnail {    overflow: hidden;    width: 230px;    height: 143px;    background: var(--anzhiyu-card-bg);    display: flex;  }    #body-wrap.error .aside-list .aside-list-item .content .title {    -webkit-line-clamp: 2;    overflow: hidden;    display: -webkit-box;    -webkit-box-orient: vertical;    line-height: 1.5;    justify-content: center;    align-items: flex-end;    align-content: center;    padding-top: 0.5rem;    color: white;  }    #body-wrap.error .aside-list .aside-list-item .content time {    display: none;  }    /* 代码框主题 */  #article-container figure.highlight {    border-radius: 10px;  }]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/js/ali_font.js"/>
      <url>/js/ali_font.js</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
  
</search>
